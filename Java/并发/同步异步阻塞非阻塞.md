# 同步异步阻塞非阻塞

## 1. 简单理解

### 1.1 同步异步

- **同步：** 同步就是调用者发起一个调用后，被调用者未处理完请求之前，调用不返回。
- **异步：** 异步就是调用者发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。

**同步和异步的区别在于同步需要调用者需要等待处理结果，异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果**。

### 1.2 阻塞和非阻塞

- **阻塞：** 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。
- **非阻塞：** 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。

**阻塞与非阻塞表示线程状态，最大区别在于阻塞会挂起当前线程，非阻塞则不会**。

### 1.3 例子

以早上妈妈叫你起床为例。

#### 1. 同步阻塞

妈妈来你房间叫你起床后，一直在门口看着你什么时候起床，在你起床之前不去做任何事。

#### 2. 同步非阻塞

妈妈来你房间叫你起床后，就去弄早餐了，每过一段时间来看一下你起床没。

#### 3. 异步阻塞

妈妈来你房间叫你起床后，你表示知道了，马上就起。但你妈妈还是一直在门口看着你什么时候起床，在你起床之前不去做任何事。

看起来是不是很奇怪。是的没错，所以一般是不会有这种情况出现的，即**没有异步阻塞**。

#### 4. 异步非阻塞

妈妈来你房间叫你起床后，你表示知道了，马上就起。然后妈妈就去弄早餐了，等你起床后有通知妈妈，我起床了。

### 1.4 小结

`同步异步`与`被调用者`有关。在处理完成后会通过回调通知调用者一般就是异步，不然就需要调用者自己查询处理结果。
`阻塞非阻塞`与`调用者`有关。调用者在发出请求后返回结果前这段时间能做其他事就是非阻塞，否则就是阻塞。

**实际上同步与异步是针对应用程序与内核的交互而言的。同步过程中进程触发IO操作并等待(也就是我们说的阻塞)或者轮询的去查看IO操作(也就是我们说的非阻塞)是否完成。 异步过程中进程触发IO操作以后，直接返回，做自己的事情，IO交给内核来处理，完成后内核通知进程IO完成。**

## 2. select/pol/epoll

### 2.1 什么是socket？什么是I/O操作？

**unix(like)世界里，一切皆文件，而文件是什么呢？文件就是一串二进制流而已，不管socket,还是FIFO、管道、终端，对我们来说，一切都是文件，一切都是流。在信息 交换的过程中，我们都是对这些流进行数据的收发操作，简称为I/O操作(input and output)**，往流中读出数据，系统调用read，写入数据，系统调用write。使用**文件描述符**来区分系统中的各种流，即通常所说的fd，一个fd就是一个整数，所以，对这个整数的操作，就是对这个文件（流）的操作。我们创建一个socket,通过系统调用会返回一个文件描述符，那么剩下对socket的操作就会转化为对这个描述符的操作。不能不说这又是一种**分层和抽象的思想**。

### 2.2 同步异步，阻塞非阻塞区别联系

**实际上同步与异步是针对应用程序与内核的交互而言的**==。`同步过程`中进程触发IO操作并`等待`(也就是我们说的阻塞)`或者轮询`的去查看IO操作(也就是我们说的非阻塞)是否完成。` 异步过程`中进程触发IO操作以后，`直接返回`，做自己的事情，IO交给内核来处理，`完成后内核通知`进程IO完成。

**`同步和异步`针对应用程序来，关注的是`程序中间的协作关系`；**

**`阻塞与非阻塞`更关注的是`单个进程的执行状态`。**

**同步有阻塞和非阻塞之分，异步没有，它一定是非阻塞的。**



**阻塞、非阻塞、多路IO复用，都是同步IO，异步必定是非阻塞的，不存在异步阻塞和异步非阻塞的说法。真正的异步IO需要CPU的深度参与**。

换句话说，只有用户线程在操作IO的时候根本不去考虑IO的执行全部都交给CPU去完成，而自己只等待一个完成信号的时候，才是真正的异步IO。**所以，拉一个子线程去轮询、去死循环，或者使用select、poll、epool，都不是异步**。

**同步：执行一个操作之后，进程触发IO操作并等待(也就是我们说的阻塞)或者轮询的去查看IO操作(也就是我们说的非阻塞)是否完成，等待结果，然后才继续执行后续的操作。**

**异步：执行一个操作后，可以去执行其他的操作，然后等待通知再回来执行刚才没执行完的操作。**

**阻塞：进程给CPU传达一个任务之后，一直等待CPU处理完成，然后才执行后面的操作。**

**非阻塞：进程给CPU传达任务后，继续处理后续的操作，过段时间再来询问之前的操作是否完成。这样的过程其实也叫轮询。**

### 2.3 select/poll/epoll

(1)select==>时间复杂度O(n)

它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以**select具有O(n)的无差别轮询复杂度**，同时处理的流越多，无差别轮询时间就越长。

**select的几大缺点：**

**（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大**

**（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大**

**（3）select支持的文件描述符数量太小了，默认是1024**

(2)poll==>时间复杂度O(n)

poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， **但是它没有最大连接数的限制**，原因是它是基于链表来存储的.

(3)epoll==>时间复杂度O(1)

**epoll可以理解为event poll**，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是**事件驱动（每个事件关联上fd）**的，此时我们对这些流的操作都是有意义的。**（复杂度降低到了O(1)）**

select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。**但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的**，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。  

epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现.



**总结：**

（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。

（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。

## 3. I/O多路复用

首先，输入操作一般包含两个步骤：

1. **等待数据准备好（waiting for data to be ready）。对于一个套接口上的操作，这一步骤关系到数据从网络到达，并将其复制到内核的某个缓冲区。**
2. **将数据从内核缓冲区复制到进程缓冲区（copying the data from the kernel to the process）。**

### 3.1 阻塞I/O模型(BIO)

![](https://images2018.cnblogs.com/blog/137084/201806/137084-20180611110813568-874888915.png)

**由上面的图可以看出，IO读分为两部分，(a)是数据通过网关到达内核，内核准备好数据，(b)数据从内核缓存写入用户缓存。**

**同步：不管是BIO,NIO,还是IO多路复用，第二步数据从内核缓存写入用户缓存一定是由 用户线程自行读取数据，处理数据。**

**异步：第二步数据是内核写入的，并放在了用户线程指定的缓存区，写入完毕后通知用户线程。****

### 3.2 非阻塞I/O模型(NIO)

当我们把一个套接口设置为非阻塞时，就是在告诉内核，当请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误。当数据没有准备好时，内核立即返回EWOULDBLOCK错误，第四次调用系统调用时，数据已经存在，这时将数据复制到进程缓冲区中。这其中有一个操作时轮询（polling）。

![img](https://images2018.cnblogs.com/blog/137084/201806/137084-20180611110823926-1104935376.png)

### 3.3 I/O复用模型

此模型用到select和poll函数，这两个函数也会使进程阻塞，select先阻塞，有活动套接字才返回，但是和阻塞I/O不同的是，**这两个函数可以同时阻塞多个I/O操作**，而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写（**就是监听多个socket**）。select被调用后，进程会被阻塞，内核监视所有select负责的socket，当有任何一个socket的数据准备好了，select就会返回套接字可读，我们就可以调用recvfrom处理数据。
**正因为阻塞I/O只能阻塞一个I/O操作，而I/O复用模型能够阻塞多个I/O操作，所以才叫做多路复用。**

![img](https://images2018.cnblogs.com/blog/137084/201806/137084-20180611110830667-163640114.png)

 

### 3.4 信号驱动I/O模型（signal driven I/O， SIGIO）

　　首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它来读取数据报。无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达(第一阶段)期间，进程可以继续执行，不被阻塞。免去了select的阻塞与轮询，当有活跃套接字时，由注册的handler处理。

### 3.5 异步I/O模型(AIO, asynchronous I/O)

　　进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。

　　这个模型工作机制是：告诉内核启动某个操作，并让内核在整个操作(包括第二阶段，即将数据从内核拷贝到进程缓冲区中)完成后通知我们。

这种模型和前一种模型区别在于：信号驱动I/O是由内核通知我们何时可以启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成。

### 3.6 小结



服务器端编程经常需要构造高性能的IO模型，常见的IO模型有四种：

* 1.同步阻塞IO（Blocking IO）：即传统的IO模型。

* 2.同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非[Java](http://lib.csdn.net/base/javase)的NIO（New IO）库。

* 3.IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，Java中的Selector和[Linux](http://lib.csdn.net/base/linux)中的epoll都是这种模型。

* 4.异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。 



