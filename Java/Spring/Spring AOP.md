# Spring AOP

## AOP简介

 AOP:**这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。** 

 

面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。
      但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。
    也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？**这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。** 
      一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。
这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。 
     AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。



`JDK动态代理`：只能针对有接口的类的接口方法进行动态代理。(接口方法默认public，所以JDK也无法对private方法进行代理)。

`CGlib动态代理`：基于继承来实现，无法对static，final类进行代理，无法对private，static方法进行代理。



## SpringAOP如何生成bean

1.如果目标对象实现了接口，则使用JDK动态代理。

2.如果目标对象没有实现接口，则使用CGlib动态代理。

3.如果目标对象实现了接口，且`强制使用CGlib代理`，则使用CGlib代理。具体为`@EnableAspectJAutoProxy(proxyTargetClass = true) `

## 问题

`实现AOP的方法被方法内部调用时是不会走AOP的织入逻辑的`

因为内部调用AOP方法的调用对象是this,而this不是增强的代理对象，所以不会走织入代码，解决方法就是用ApplicationContent获取到增强的代理对象的bean，然后用这个bean来执行AOP方法，就可以走织入的代码逻辑了

## SpringAOP 概念

AOP称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待，Struts2的拦截器设计就是基于AOP的思想，是个比较经典的例子。

一 AOP的基本概念

(1)**Aspect(切面)** :通常是**带有`@Aspect`注解一个类**，里面可以定义`切入点`和`通知`。

(2)**Pointcut(切入点)** :就是带有通知的连接点，在程序中主要体现为**定位到具体方法的一个表达式**。

(3)**Advice(通知)** :AOP在特定的切入点上执行的增强处理，before,after,afterReturning,afterThrowing,around，**定位到方法后干什么事**

(4)JointPoint(连接点):程序执行过程中明确的点，一般是方法的调用

(5)AOP代理：AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类

**重点就是Aspect(切面)、Pointcut(切入点)、Advice(通知)三个**。

二 Spring AOP

Spring中的AOP代理还是离不开Spring的IOC容器，代理的生成，管理及其依赖关系都是由IOC容器负责，Spring默认使用JDK动态代理，在需要代理类而不是代理接口的时候，Spring会自动切换为使用CGLIB代理，不过现在的项目都是面向接口编程，所以JDK动态代理相对来说用的还是多一些。