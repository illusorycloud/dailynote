# Java 集合

![img](https://img-blog.csdn.net/20160124221843905) 

## 具体分析

### 1.Iterator

迭代器，它是Java集合的顶层接口（不包括 map 系列的集合，Map接口 是 map 系列集合的顶层接口） 

### 2.Collection

List 接口和 Set 接口的父接口 

### 3.List

 有序，可以重复的集合。 

#### 3.1ArryaList

　底层数据结构是`数组`，查询快，增删慢;线程不安全，效率高 





#### 3.2LinkedList

底层数据结构是`链表，`查询慢，增删快;线程不安全，效率高 

 

### 4.Set

典型实现 HashSet()是一个无序，不可重复的集合 

#### 4.1HashSet

不能保证元素的顺序；不可重复；不是线程安全的；集合元素可以为 NULL;

 底层其实是一个`数组`，存在的意义是加快查询速度。 

元素在HashSet中的位置由HashCode决定。

存元素时，若该位置已经有值，即两个元素hashCode相同，此时要通过equals()方法判断是否为同一元素、

equals 为 true，则视为同一个对象，不保存在 hashSet（）中；

hashCode 相同，equals 为 false，则存储在之前对象同槽位的链表上，这非常麻烦，我们应该约束这种情况，

即保证：如果两个对象通过 equals() 方法返回 true，这两个对象的 hashCode 值也应该相同。 



## 遍历方式

```java
结论：对于顺序存储用for循环遍历，对于链式存储则用iterator比较好。foreach 内部 也是采用iterator实现
if (list instanceof RandomAccess) {
    //使用传统的for循环遍历。
} else {
    //使用Iterator或者foreach。
}
```

存储方式：

1、顺序存储，Random Access（Direct Access）：

​        这种方式，相邻的数据元素存放于相邻的内存地址中，整块内存地址是连续的。可以根据元素的位置直接计算出内存地址，直接进行读取。读取一个特定位置元素的平均时间复杂度为O(1)。正常来说，只有基于数组实现的集合，才有这种特性。Java中以`ArrayList`为代表。

2、链式存储，Sequential Access：

​        这种方式，每一个数据元素，在内存中都不要求处于相邻的位置，每个数据元素包含它下一个元素的内存地址。不可以根据元素的位置直接计算出内存地址，只能按顺序读取元素。读取一个特定位置元素的平均时间复杂度为O(n)。主要以链表为代表。Java中以`LinkedList`为代表。



**集合类的通用遍历方式, 用迭代器迭代: ** map除外

Iterator it = list.iterator();

while(it.hasNext()) {

　　Object obj = it.next();

}

**Map**

1.entrySet

2.entrySet().iterator()

3.entrySet（**推荐使用尤其是容量大时** ）

```java
private void map() {
    Map<String, String> map = new HashMap<>();
    map.put("age", "22");
    map.put("name", "lillusory");
    map.put("address", "CQ");
    //1.keySet
    System.out.println("--------------keySet---------");
    for (String str : map.keySet()) {
        System.out.println("key= " + str + "value= " + map.get(str));
    }
    System.out.println("-----------------------");
    //2.entrySet.Iterator
    System.out.println("--------------entrySet.Iterator---------");
    Iterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String, String> entry = iterator.next();
        System.out.println("key= " + entry.getKey() + "value= " + entry.getValue());
    }
    System.out.println("-----------------------");
    //3.entrySet
    System.out.println("--------------entrySet---------");
    for (Map.Entry<String, String> entry : map.entrySet()) {
        System.out.println("key= " + entry.getKey() + " value= " + entry.getValue());
    }
    System.out.println("-----------------------");
}
```

**List**

1.foreach

2.Iterator

3.for

```java
private void list() {
    List<String> list = new ArrayList<>();
    list.add("Tom");
    list.add("Jack");
    list.add("Bob");
    //1.foreach
    System.out.println("----------foreach-----------");
    for (String str : list
            ) {
        System.out.println(str);
    }
    System.out.println("-----------------------");
    //2.Iterator
    System.out.println("----------Iterator-----------");
    Iterator<String> iterator = list.iterator();
    while (iterator.hasNext()) {
        String str = iterator.next();
        System.out.println(str);
    }
    System.out.println("-----------------------");
    //3.for
    System.out.println("----------for-----------");
    for (int i = 0; i < list.size(); i++) {
        String s = list.get(i);
        System.out.println(s);
    }
    System.out.println("-----------------------");
    
}
```