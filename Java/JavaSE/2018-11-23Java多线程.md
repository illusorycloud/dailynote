# 1.Java多线程



  **程序:**一段静态的代码，一组指令的有序集合，它本身没有任何运行的含义，它只是一个静态的实体，是应用软件执行的蓝本。 

**进程：**进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程 

**线程：**可以理解为进程的多条执行线索，每条线索又对应着各自独立的生命周期。线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。



## 等待/通知（wait/notify）机制

线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()/notifyAll()方法，线程A收到通知后退出等待队列，进入可运行状态，进而执行后续操作。 

| wait()     | 使调用该方法的线程释放共享资源锁，然后从运行状态退出，进入等待队列，直到被再次唤醒 |
| ---------- | ------------------------------------------------------------ |
| wait(long) | 超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回 |

| notify()    | 随机唤醒等待队列中等待同一共享资源的 **“一个线程”**，并使该线程退出等待队列，进入可运行状态，也就是**notify()方法仅通知“一个线程”** |
| ----------- | ------------------------------------------------------------ |
| notifyAll() | 使所有正在等待队列中等待同一共享资源的 **“全部线程”** 退出等待队列，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行，这取决于JVM虚拟机的实现 |



1.新建(new)：新创建了一个线程对象。 

2.可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。 

3.运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。 

4.阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：

(一). **等待阻塞**：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waitting queue)中。

(二). **同步阻塞**：运行(running)的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。

(三). **其他阻塞**: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞

5.**死亡(dead)**：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 

# 2..synchronized关键字

synchronized关键字加到static静态方法和synchronized(class)代码块上都是是给Class类上锁，而synchronized关键字加到非static静态方法上是给对象上锁。 

# 3.volatile关键字

```
1.保证数据的可见性
2.禁止JVM的优化重排序
```

volatile关键字可以用来提醒编译器它后面所定义的变量随时有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。

**volatile 修饰的成员变量**在每次被线程访问时，都强迫**从主存（共享内存）中重读该成员变量的值**。而且，当成员变量发生变化时，**强迫线程将变化值回写到主存（共享内存）**。这样在任何时刻，**两个不同的线程总是看到某个成员变量的同一个值**，这样也就保证了同步数据的**可见性**。 



# 4.线程间通信知识点补充

## 1.管道输入/输出流

**管道输入/输出流主要用于线程之间的数据传输**，而且传输的媒介为**内存**。

管道输入/输出流主要包括下列两类的实现：

**面向字节**： PipedOutputStream、 PipedInputStream

**面向字符**: PipedWriter、 PipedReader

## 2.Thread.join()的使用

主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。另外，一个线程需要等待另一个线程也需要用到join()方法。

Thread类除了提供join()方法之外，还提供了join(long millis)、join(long millis, int nanos)两个具有超时特性的方法。这两个超时方法表示，如果线程thread在指定的超时时间没有终止，那么将会从该超时方法中返回。

## 3.ThreadLocal的使用

如果想实现每一个线程都有自己的共享变量该如何解决呢？JDK中提供的ThreadLocal类正是为了解决这样的问题。ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。 

| 方法名称       | 描述                                           |
| -------------- | ---------------------------------------------- |
| get()          | 返回当前线程的此线程局部变量的副本中的值       |
| set(T value)   | 将当前线程的此线程局部变量的副本设置为指定的值 |
| remove()       | 删除此线程局部变量的当前线程的值。             |
| initialValue() | 返回此线程局部变量的当前线程的“初始值”         |

**InheritableThreadLocal**

ThreadLocal类固然很好，但是子线程并不能取到父线程的ThreadLocal类的变量，InheritableThreadLocal类就是解决这个问题的。 

# Lock锁的使用

在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的。JDK1.5之后并发包中新增了Lock接口以及相关实现类来实现锁功能。 锁是用于通过多个线程控制对共享资源的访问的工具 

```java
  Lock lock=new ReentrantLock()；
  lock.lock();
   try{
    }finally{
    lock.unlock();
    }
```

| 方法名称                                  | 描述                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| void lock()                               | 获得锁。如果锁不可用，则当前线程将被禁用以进行线程调度，并处于休眠状态，直到获取锁。 |
| void lockInterruptibly()                  | 获取锁，如果可用并立即返回。如果锁不可用，那么当前线程将被禁用以进行线程调度，并且处于休眠状态，和lock()方法不同的是在锁的获取中可以中断当前线程（相应中断）。 |
| Condition newCondition()                  | 获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的wait()方法，而调用后，当前线程将释放锁。 |
| boolean tryLock()                         | 只有在调用时才可以获得锁。如果可用，则获取锁定，并立即返回值为true；如果锁不可用，则此方法将立即返回值为false 。 |
| boolean tryLock(long time, TimeUnit unit) | 超时获取锁，当前线程在一下三种情况下会返回： 1. 当前线程在超时时间内获得了锁；2.当前线程在超时时间内被中断；3.超时时间结束，返回false. |
| void unlock()                             | 释放锁。                                                     |

## ReentrantLock

Lock接口的实现类

**ReentrantLock（排他锁）具有完全互斥排他的效果，即同一时刻只允许一个线程访问** 

ReentrantLock和synchronized关键字一样可以用来实现线程之间的同步互斥，但是在功能是比synchronized关键字更强大而且更灵活。

## Condition接口

synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制;

ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。

在使用notify/notifyAll()方法进行通知时，被通知的线程是有JVM选择的，使用ReentrantLock类结合Condition实例可以实现“选择性通知”，这个功能非常重要，而且是Condition接口默认提供的。

方法名称	描述
void await()	相当于Object类的wait方法
boolean await(long time, TimeUnit unit)	相当于Object类的wait(long timeout)方法
signal()	相当于Object类的notify方法

signalAll()	相当于Object类的notifyAll方法

在使用wait/notify实现等待通知机制的时候我们知道必须执行完notify()方法所在的synchronized代码块后才释放锁。在这里也差不多，必须执行完signal所在的try语句块之后才释放锁，condition.await()后的语句才能被执行。 

## ReentrantReadWriteLock

读写锁维护了两个锁，一个是读操作相关的锁也成为共享锁，一个是写操作相关的锁 也称为排他锁。通过分离读锁和写锁，其并发性比一般排他锁有了很大提升。

多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥（只要出现写操作的过程就是互斥的。）。

# 5.并发编程中一些问题

### 减少上下文切换

#### 上下文切换

当前任务在执行完CPU时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。 **上下文切换对系统来说意味着消耗大量的 CPU 时间** 。

上下文切换又分为2种**：让步式上下文切换和抢占式上下文切换**。前者是指执行线程主动释放CPU，与锁竞争严重程度成正比，可通过**减少锁竞争**和使用**CAS算法**来避免；后者是指线程因分配的时间片用尽而被迫放弃CPU或者被其他优先级更高的线程所抢占，一般由于线程数大于CPU可用核心数引起，可通过适当**减少线程数**和**使用协程**来避免。

#### 总结：

减少锁的使用。因为多线程竞争锁时会引起上下文切换。
使用CAS算法。这种算法也是为了减少锁的使用。CAS算法是一种无锁算法。
减少线程的使用。人物很少的时候创建大量线程会导致大量线程都处于等待状态。

使用协程。

#### CAS算法

```
CAS（比较与交换，Compare and swap） 是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。实现非阻塞同步的方案称为“无锁编程算法”（ Non-blocking algorithm）。 

相对应的，独占锁是一种悲观锁，synchronized就是一种独占锁，它假设最坏的情况，并且只有在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。
```

#### 协程

```
协程也可以说是微线程或者说是轻量级的线程，它占用的内存更少并且更灵活。很多编程语言中都有协程。Lua, Ruby 等等都有自己的协程实现。
```

### 避免死锁

根据《Java并发编程的艺术》有下面四种避免死锁的常见方法：

避免一个线程同时获得多个锁
避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制

对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

### 解决资源限制

```
在并发编程中，程序运行加快的原因是运行方式从串行运行变为并发运行，但是如果如果某段程序的并发执行由于资源限制仍然在串行执行的话，这时候程序的运行不仅不会加快，反而会更慢，因为可能增加了上下文切换和资源调度的时间。
解决：
对于硬件资源限制，可以考虑使用集群并行执行程序。既然单机的资源有限制，那么就让程序在多机上运行。比如使用Hadoop或者自己搭建服务器集群。

对于软件资源的限制，可以考虑使用资源池将资源复用。比如使用连接池将数据库和Socket复用，或者在调用对方webservice接口获取数据时，只建立一个连接。另外还可以考虑使用良好的开源软件。
```

# 6.线程池与Executor 框架

使用线程池的好处：

```
降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。

提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
```



FixedThreadPool： 适用于为了满足资源管理需求，而需要限制当前线程数量的应用场景。它适用于负载比较重的服务器；

SingleThreadExecutor： 适用于需要保证顺序地执行各个任务并且在任意时间点，不会有多个线程是活动的应用场景。

CachedThreadPool： 适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器；

ScheduledThreadPoolExecutor： 适用于需要多个后台执行周期任务，同时为了满足资源管理需求而需要限制后台线程的数量的应用场景，

SingleThreadScheduledExecutor： 适用于需要单个后台线程执行周期任务，同时保证顺序地执行各个任务的应用场景。





[全文地址](https://github.com/Snailclimb/JavaGuide/blob/master/Java%E7%9B%B8%E5%85%B3/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97.md)