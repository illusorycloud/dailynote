# HashMap

##  HashMap的长度为什么要是2的n次方

HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；
这个算法实际就是取模`hash%length`计算机中直接求余效率不如位移运算，源码中做了优化`hash&(length-1)`，
hash%length==hash&(length-1)的前提是length是2的n次方；
为什么这样能均匀分布减少碰撞呢？2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1；
例如长度为9时候，3&(9-1)=0  2&(9-1)=0 ，都在0上，碰撞了；
例如长度为8时候，3&(8-1)=3  2&(8-1)=2 ，不同位置上，不碰撞；

其实就是按位“与”的时候，每一位都能  &1  ，也就是和1111……1111111进行与运算



## 多线程下hashMap死循环问题

hashmap 假设开始时为1位置下有（ 8-->3-->5-->null） 2位置有 (9-->null);

然后扩容时会先扩容然后将以前的内容复制到新的map中，且会重新计算hashcode,进行排序。

这个过程同时来了两个线程 都进行扩容操作 第一个线程在扩容后准备复制数据时阻塞了，但已经记录下了数据的位置（8-->3-->5-->nul），此时线程二进行扩容,同时进行重新计算hashcode,重新为数据计算位置。新排序后位置假设为 1位置下有（3-->8-->5-->null） 2位置下有（9-->null） 线程二执行完成。此时3指向的时8

线程一继续执行，开始复制数据 （注意，此时线程一的记录还是以前的1位置下有（ 8-->3-->5-->null） 2位置有 (9-->null) 由8-->3;  第一次为 8-->3, 第一次对8重新计算hashcode找位置结束后，到了第二次读取到了新的数据 ，即线程2排序后的数据（3-->8-->5-->null），此时线程1已经记录下了8-->3 这部分了 然后读取到新数据发现 3的下一个数据是8，即3-->8 此时就已经形成死循环了。3-->8-->3  当然并不影响线程1继续复制数据扩容。但是在下次get获取数据时会卡在死循环这里 cpu占用一直上升。

多线程下用推荐使用concurrenthashmap

