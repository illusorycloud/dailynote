## 1.  语音留言聊天等大文件或大数据量的主流实现方式？

  移动网络因为网络不稳定的客观因素存在，不适合实时发送较大的2进制文件（像电脑上的实时文件发送的那种），因为这涉及3方：客户端A、服务端、客户端B，任何两方的通讯因网络的不稳定而导致的重传等，都是个很不好处理的事情。

现在多数情况下都是通过http先上传到中转文件服务器，成功后再通知接收方，这种情况下，因上传的过程只限于客户端A和服务端，只涉及两方，网络的不稳定，也只影响了发送者（而不涉及接收者，因为对方还不知道你正在发送文件呢），所以无论是从可靠性、复杂性，还是用户体验的处理上，这种方式都要简单的多。而这么多年的移动应用也证明，这种云中转暂存的方式是比较适合于当前的移动网络和移动应用体验的。  

**应该是发送方把语音文件上传到服务器成功后，同时发一条语音消息（只是一个包含了音频下载地址信息，可能是个文件名或url）发给接收方，接收方只在点击时才下载**。

发送图片，录音，录像的思路是，先通过http上传图片，录音，录像到服务端，然后要求服务端返回图片录音录像的地址到客户端，然后客户端发送json，发送图片地址录音录像的地址给IM，IM通过推送给另外的客户端，客户端收到以后，通过解析json，然后通过http下载视频图片，语音，，图片的话要进行缩放，录音的华，要有特定的图标标示，录像的话，下载以后截取第一帧的图片，不过建议这样，在展示图片的时候，缩放，在展示录像录音的时候，直接用图标替代展示的录像录音，然后通过用户点击图标通过http下载录音视频得到这种效果，此类功能需要一个ftp服务器，进行处理



你对心跳的理解可能有点混淆，我来给你解释一下。

## 2. QoS心跳和keep alive心跳

1关于Keep Alive心跳

通常来说，IM里的心跳指的是为了TCP或UDP通讯的socket保活而进行的定时向服务端发送keep alive包的机制。

一般来说Keep Alive心跳的作用至少有两个：

1）解决UDP或TCP的端口老化问题（UDP的端口老化时间更短）；

2）告诉服务器我还活着（极端情况下，当客户端因程序崩溃等情况而非常退出时，心跳就显得特别重要，尤其在使用UDP这样的“无连接”协议的情况下）。

你上面的理解有关3次握手的概念，这是错误的，心跳机制跟这完全没关系。

2关于QOS

我们讲讲应答机制：

主流的IM（不管是IM云还是像微信这样的产品），都会这个消息应答机制（易信就特别明显，你甚至可以看到对方读消息的时间，也同样是用的应答机制），且无论是UDP协议还是TCP协议。应答机制通常是在消息接收者收到消息的同时，马上发送应答包，发送方只需根据这个应答包来决定对方是否真的是否“收到”消息，这就让丢包（当然丢包的情况有很多种可能，UDP协议自身的特殊性只是其中一种）的判定变的简单。

再来讲讲重传机制：

这个重传机制，跟你说的心跳是差不多的，但是用“心跳”可能容易跟Keep alive机制混淆，所以叫定时线程，可能更准确。它的工作原理是，定期检查已发送队列，当包的生存期已过，就表示这个包从未收到应答包，也就认为着它没有被接收方“收到”，那么自动触发重传机制。

当然，应答和重传机制在MobileIMSDK或者其它IM框架里，实际的实现都比我上面描述的要复杂和强大，我只是为了向你简单地描述原理而已。

以上大概就是这样，我以后会把流程图整理出来。希望能解决你的疑问。

## 3. 如何保证消息不丢失

http://www.52im.net/thread-294-1-1.html

```java
ClientA -->  imServer --> ClientB
ClientA<--	 imServer <--ClientB
```



- client-A向im-server发送一个消息请求包，即msg:R
- im-server在成功处理后，回复client-A一个消息响应包，即msg:A
- 如果此时client-B在线，则im-server主动向client-B发送一个消息通知包，即msg:N（当然，如果client-B不在线，则消息会存储离线）

从流程图中容易看到，发送方client-A收到msg:A后，只能说明im-server成功接收到了消息，并不能说明client-B接收到了消息。在若干场景下，可能出现msg:N包丢失，且发送方client-A完全不知道，例如：

- 服务器崩溃，msg:N包未发出
- 网络抖动，msg:N包被网络设备丢弃
- client-B崩溃，msg:N包未接收

结论是悲观的：接收方client-B是否有收到msg:N，发送方client-A完全不可控，那怎么办呢？

要想让发送方client-A确保接收方client-B收到了消息，必须让接收方client-B给一个消息的确认，这个应用层的确认的流程，与消息的发送流程类似：

- client-B向im-server发送一个ack请求包，即ack:R
- im-server在成功处理后，回复client-B一个ack响应包，即ack:A
- 则im-server主动向client-A发送一个ack通知包，即ack:N



期望六个报文完成消息的可靠投递，但实际情况下：

- **msg:R，msg:A 报文可能丢失：**
  此时直接提示“发送失败”即可，问题不大；

- **msg:N，ack:R，ack:A，ack:N这四个报文都可能丢失：**
  （原因如第二章所述，可能是服务器奔溃、网络抖动、或者客户端奔溃），此时client-A都收不到期待的ack:N报文，即client-A不能确认client-B是否收到“你好”。
  3、本文概述
  消息的可靠性，即消息的不丢失和不重复，是IM系统中的一个难点。当初QQ在技术上（当时叫OICQ）因为以下两点原因才打败了ICQ：
  QQ的消息投递可靠（消息不丢失，不重复）；QQ的垃圾消息少（它antispam做得好，这也是一个难点，但不是本文重点讨论的内容）。
  今天，本文将用十分通俗的语言，来讲述IM系统中消息可靠性的问题。
  4、报文类型
  IM的客户端与服务器通过发送报文（也就是请求包）来完成消息的传递。
  **报文分为三种：**
  请求报文（request，后简称为为R）；应答报文（acknowledge，后简称为A）；通知报文（notify，后简称为N）。
  这三种报文的解释如下：
  ![IM消息送达保证机制实现(一)：保证在线实时消息的可靠投递_1.png](http://www.52im.net/data/attachment/forum/201611/13/224300prf39n7ff5jr9uu4.png) 
  R：客户端主动发送给服务器的报文A：服务器被动应答客户端的报文，一个A一定对应一个RN：服务器主动发送给客户端的报文
  5、普通消息投递流程
  **用户A给用户B发送一个“你好”，很容易想到，流程如下：**
  ![IM消息送达保证机制实现(一)：保证在线实时消息的可靠投递_2.png](http://www.52im.net/data/attachment/forum/201611/13/224301vyyfwjqylf0jylq6.png) 
  client-A向im-server发送一个消息请求包，即msg:Rim-server在成功处理后，回复client-A一个消息响应包，即msg:A如果此时client-B在线，则im-server主动向client-B发送一个消息通知包，即msg:N（当然，如果client-B不在线，则消息会存储离线）
  6、上述消息投递流程出现的问题
  从流程图中容易看到，发送方client-A收到msg:A后，只能说明im-server成功接收到了消息，并不能说明client-B接收到了消息。在若干场景下，可能出现msg:N包丢失，且发送方client-A完全不知道，例如：
  服务器崩溃，msg:N包未发出网络抖动，msg:N包被网络设备丢弃client-B崩溃，msg:N包未接收
  结论是悲观的：接收方client-B是否有收到msg:N，发送方client-A完全不可控，那怎么办呢？
  7、应用层确认+im消息可靠投递的六个报文
  我们来参考网络传输协议的实现：UDP是一种不可靠的传输层协议，TCP是一种可靠的传输层协议，TCP是如何做到可靠的？答案是：超时、重传、确认。（即时通讯网注：实际上IM中，数据通讯层无论用的是UDP还是TCP协议，都同样需要消息送达保证（即QoS）机制，原因在于IM的通信是A端-Server-B端的3方通信，而非传统C/S或B/S这种2方通信）。
  要想实现应用层的消息可靠投递，必须加入应用层的确认机制，即：要想让发送方client-A确保接收方client-B收到了消息，必须让接收方client-B给一个消息的确认，这个应用层的确认的流程，与消息的发送流程类似：
  client-B向im-server发送一个ack请求包，即ack:Rim-server在成功处理后，回复client-B一个ack响应包，即ack:A则im-server主动向client-A发送一个ack通知包，即ack:N
  至此，发送“你好”的client-A，在收到了ack:N报文后，才能确认client-B真正接收到了“你好”。
  你会发现，一条消息的发送，分别包含（上）（下）两个半场，即msg的R/A/N三个报文，ack的R/A/N三个报文。一个应用层即时通讯消息的可靠投递，共涉及6个报文，这就是im系统中消息投递的最核心技术（如果某个im系统不包含这6个报文，不要谈什么消息的可靠性）。
  8、可靠消息投递存在什么问题
  **期望六个报文完成消息的可靠投递，但实际情况下：**
  **msg:R，msg:A 报文可能丢失：**
  此时直接提示“发送失败”即可，问题不大；**msg:N，ack:R，ack:A，ack:N这四个报文都可能丢失：**
  （原因如第二章所述，可能是服务器奔溃、网络抖动、或者客户端奔溃），此时client-A都收不到期待的ack:N报文，即client-A不能确认client-B是否收到“你好”。
  那怎么办呢？
  9、消息的超时与重传
  client-A发出了msg:R，收到了msg:A之后，在一个期待的时间内，如果没有收到ack:N，client-A会尝试将msg:R重发。可能client-A同时发出了很多消息，故client-A需要在本地维护一个等待ack队列，并配合timer超时机制，来记录哪些消息没有收到ack:N，以定时重发。
  ![IM消息送达保证机制实现(一)：保证在线实时消息的可靠投递_3.png](http://www.52im.net/data/attachment/forum/201611/13/224301envhst9pv9cx7czn.png) 
  一旦收到了ack:N，说明client-B收到了“你好”消息，对应的消息将从“等待ack队列”中移除。
  10、消息的重传存在什么问题
  **第五节提到过，msg:N报文，ack:N报文都有可能丢失：**
  **msg:N 报文丢失：**说明client-B之前压根没有收到“你好”报文，超时与重传机制十分有效**ack:N 报文丢失：**说明client-B之前已经收到了“你好”报文（只是client-A不知道而已），超时与重传机制将导致client-B收到重复的消息。
  **启示：**
  平时使用qq，或许大伙都有类似的体验，弹出一个对话框“因为网络原因，消息发送失败，是否要重发”，此时，有可能是对方没有收到消息（发送方网络不好，msg:N丢失），也可能已经收到了消息（接收方网络不好，反复重传后，ack:N依然丢失），出现这个提示时，大伙不妨和对端确认一下，看是哪种情况。
  11、消息的去重
  解决方法也很简单，由发送方client-A生成一个消息去重的msgid，保存在“等待ack队列”里，同一条消息使用相同的msgid来重传，供client-B去重，而不影响用户体验。
  12、其他
  1）上述设计理念，由客户端重传，可以保证服务端无状态性（架构设计基本准则）；
  2）如果client-B不在线，im-server保存了离线消息后，要伪造ack:N发送给client-A；
  3）离线消息的拉取，为了保证消息的可靠性，也需要有ack机制，但由于拉取离线消息不存在N报文，故实际情况要简单的多，即先发送offline:R报文拉取消息，收到offline:A后，再发送offlineack:R删除离线消息。
  13、总结

  **im系统是通过超时、重传、确认、去重的机制来保证消息的可靠投递，不丢不重**；
  **切记，一个“你好”的发送，包含上半场msg:R/A/N与下半场ack:R/A/N的6个报文**。
  个人消息是一个1对1的ack，群消息就没有这么简单了，群消息存在一个扩散系数，im群消息的可靠投递问题感兴趣的可查阅相关资料。

**实际上IM中，数据通讯层无论用的是UDP还是TCP协议，都同样需要消息送达保证（即QoS）机制，原因在于IM的通信是A端-Server-B端的3方通信，而非传统C/S或B/S这种2方通信**.

## 4. **IM该如何设计“失败重试”机制？**

做法一: 上层做重发，例如可以失败后第一次10秒重发，再失败30秒，再失败60秒，再失败提示用户。

 做法二: 失败直接提示用户，让用户主动去重发。 无论哪种做法，只是产品设计的不同，**都需要做去重处理，每个客户端要维护一个自增长id，服务器只保存收到的最后一条消息的id，客户端再来消息后，只需要判断来自客户端的id是否大于服务器保存的这个就可以**。