# 深入理解Java虚拟机

## 第一章 走进Java

### 展望Java技术的未来

模块化

混合语言 项目中每个应用层使用不同的需要，发挥各自的优点，中间层使用Java。

多核并行 

进一步丰富语法  

64位虚拟机

## 第二章 自动内存管理机制

### 2.1 运行时数据区

#### 1.程序计数器   

线程独立的。可以看做是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

#### 2.java虚拟机栈

生命周期和线程相同，线程独立。每个方法在执行时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到执行完成的过程就是一个栈帧在虚拟机中的入栈到出栈的过程。

局部变量表：存放了编译时期可知的各种基本类型（Boolean，byte，char,short,int.float.long,double）、对象引用（reference类型）和returnAddress（指向了一条字节码指令的地址）

#### 3.本地方法栈

和Java虚拟机栈作用相似，不过这是为虚拟机执行Native方法服务的，线程独立的。

#### 4.堆

Java堆是虚拟机所管理的内存中最大的一块了。线程共享，在虚拟机启动时创建。也是垃圾回收的主要区域。Java虚拟机规范中说的是：所有的对象实例以及数组都要在堆上分配内存。但是随着`JIT(just in time)编译器`的发展与`逃逸分析`技术的成熟，`栈上分配`，`标量替换`优化技术将会导致一些微妙的变化，所有对象都分配在堆上也变得不是那么绝对了。

垃圾回收器都采用分代回收算法。所以Java堆可以细分为`新生代`和`老年代`。在细致一点可以分为`Eden空间`，`From Survivor`,`To Survivor`等。

#### 5.方法区

也是线程共享的区域。用于存储已被虚拟机加载的`类信息`,`常量`，`静态变量`，`即时编译器编译后的代码`等数据。

java虚拟机把方法区描述为堆的一个逻辑区域，但是方法区却有一个别名`Non-Heap非堆`目的应该是和Java堆区分开。

#### 6.运行时常量池

`运行时常量池`是`方法区`的一部分。Java Class文件中除了有类的版本，字段，方法，接口等描述信息外还有一项信息是`常量池`,用于存放编译期生成的各种`字面量`和`符号引用`，这部分内容将在`类加载后`进入方法区的`运行时常量池`。

##### 全局字符串池

全局字符串池里的内容是在类加载完成，经过验证，**准备阶段之后**在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。

##### class文件常量池（class constant pool）

Java Class文件中除了有类的版本，字段，方法，接口等描述信息外还有一项信息是`常量池`,用于存放编译期生成的各种`字面量`和`符号引用`，这部分内容将在`类加载后`进入方法区的`运行时常量池`。

 字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。 符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

##### 运行时常量池

jvm在执行某个类的时候，必须经过`加载`、`连接`、`初始化`，而连接又包括`验证`、`准备`、`解析`三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，`运行时常量池也是每个类都有一个`。在上面我也说了，`class常量池中存的是字面量和符号引用`，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过`解析（resolve）`之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。

##### 小结

- 1.全局常量池在每个VM中只有一份，存放的是字符串常量的引用值。
- 2.class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。
- 3.运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。

#### 7.直接内存

直接内存并不是虚拟机运行时数据区的一部分，但是也频繁被用到，也可能导致OOM,虚拟机内存+直接内存超过物理内存时。

在JDK1.4出现的NIO类中引入了一个基于Channel和Buffer的IO方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，能在一些场合中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

#### 8.对象的创建

##### 1.类加载检查

虚拟机遇到new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过。若没有则必须先执行相应的类加载过程。

##### 2.分配内存空间

在类加载检查完成后，接下来虚拟机开始为新生对象分配内存，对象所需内存大小在类加载完成后即可完全确定。

**问题：**

这里有一个问题就是对象创建在虚拟机中是非常频繁的，并发情况下可能会有线程安全问题。可能出现正在给对象A分配内存，指针还没来得及修改，对象B又使用的原来的指针来分配内存。

**解决方案：**

有两种解决方案。

一种是对分配内存空间的动作进行同步处理----实际上虚拟机采用CAS配上失败重试的方式，保证更新操作的原子性。

另一种是把内存分配的动作放在不同的空间中进行，即每个线程在Java堆中预先分配一块内存，称为本地线程分配缓冲TLAB（Thread Local Allocation Buffer），分配内存时优先在线程自己的TALB上分配，因为`在TLAB上分配对象时不需要加锁`，只有TALB用完后分配新的TALB时才需要同步锁定。

##### 3.初始化零值

内存分配完成后，虚拟机将分配到的内存空间都初始化为零值（零值根据对象类型不同也不同，这就是为什么对象的实例字段在Java代码中不用初始化也可以使用），若使用TLAB，则这一步可以提前至TALB分配时进行。

##### 4.设置对象头

接下来是对象头的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄信息等。这些信息都存放在对象的对象头中。

##### 5.init初始化

前面几步执行后，在虚拟机角度一个对象已经创建完成了，但是在Java程序角度对象的创建才刚开始，因为init方法还没执行。所以一般来说执行new指令后还会执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来了。