# 深入理解Java虚拟机

## 第一章 走进Java

### 展望Java技术的未来

模块化

混合语言 项目中每个应用层使用不同的需要，发挥各自的优点，中间层使用Java。

多核并行 

进一步丰富语法  

64位虚拟机

## 第二章 自动内存管理机制

### 2.1 运行时数据区

#### 1.程序计数器   

线程独立的。可以看做是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

#### 2.java虚拟机栈

生命周期和线程相同，线程独立。每个方法在执行时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到执行完成的过程就是一个栈帧在虚拟机中的入栈到出栈的过程。

局部变量表：存放了编译时期可知的各种基本类型（Boolean，byte，char,short,int.float.long,double）、对象引用（reference类型）和returnAddress（指向了一条字节码指令的地址）

#### 3.本地方法栈

和Java虚拟机栈作用相似，不过这是为虚拟机执行Native方法服务的，线程独立的。

#### 4.堆

Java堆是虚拟机所管理的内存中最大的一块了。线程共享，在虚拟机启动时创建。也是垃圾回收的主要区域。Java虚拟机规范中说的是：所有的对象实例以及数组都要在堆上分配内存。但是随着`JIT(just in time)编译器`的发展与`逃逸分析`技术的成熟，`栈上分配`，`标量替换`优化技术将会导致一些微妙的变化，所有对象都分配在堆上也变得不是那么绝对了。

垃圾回收器都采用分代回收算法。所以Java堆可以细分为`新生代`和`老年代`。在细致一点可以分为`Eden空间`，`From Survivor`,`To Survivor`等。

#### 5.方法区

也是线程共享的区域。用于存储已被虚拟机加载的`类信息`,`常量`，`静态变量`，`即时编译器编译后的代码`等数据。

java虚拟机把方法区描述为堆的一个逻辑区域，但是方法区却有一个别名`Non-Heap非堆`目的应该是和Java堆区分开。

#### 6.运行时常量池

`运行时常量池`是`方法区`的一部分。Java Class文件中除了有类的版本，字段，方法，接口等描述信息外还有一项信息是`常量池`,用于存放编译期生成的各种`字面量`和`符号引用`，这部分内容将在`类加载后`进入方法区的`运行时常量池`。

##### 全局字符串池

全局字符串池里的内容是在类加载完成，经过验证，**准备阶段之后**在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。

##### class文件常量池（class constant pool）

Java Class文件中除了有类的版本，字段，方法，接口等描述信息外还有一项信息是`常量池`,用于存放编译期生成的各种`字面量`和`符号引用`，这部分内容将在`类加载后`进入方法区的`运行时常量池`。

 字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。 符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

##### 运行时常量池

jvm在执行某个类的时候，必须经过`加载`、`连接`、`初始化`，而连接又包括`验证`、`准备`、`解析`三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，`运行时常量池也是每个类都有一个`。在上面我也说了，`class常量池中存的是字面量和符号引用`，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过`解析（resolve）`之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。

##### 小结

- 1.全局常量池在每个VM中只有一份，存放的是字符串常量的引用值。
- 2.class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。
- 3.运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。

#### 7.直接内存

直接内存并不是虚拟机运行时数据区的一部分，但是也频繁被用到，也可能导致OOM,虚拟机内存+直接内存超过物理内存时。

在JDK1.4出现的NIO类中引入了一个基于Channel和Buffer的IO方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，能在一些场合中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

#### 8.对象的创建

##### 1.类加载检查

虚拟机遇到new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过。若没有则必须先执行相应的类加载过程。

##### 2.分配内存空间

在类加载检查完成后，接下来虚拟机开始为新生对象分配内存，对象所需内存大小在类加载完成后即可完全确定。

**问题：**

这里有一个问题就是对象创建在虚拟机中是非常频繁的，并发情况下可能会有线程安全问题。可能出现正在给对象A分配内存，指针还没来得及修改，对象B又使用的原来的指针来分配内存。

**解决方案：**

有两种解决方案。

一种是对分配内存空间的动作进行同步处理----实际上虚拟机采用CAS配上失败重试的方式，保证更新操作的原子性。

另一种是把内存分配的动作放在不同的空间中进行，即每个线程在Java堆中预先分配一块内存，称为本地线程分配缓冲TLAB（Thread Local Allocation Buffer），分配内存时优先在线程自己的TALB上分配，因为`在TLAB上分配对象时不需要加锁`，只有TALB用完后分配新的TALB时才需要同步锁定。

##### 3.初始化零值

内存分配完成后，虚拟机将分配到的内存空间都初始化为零值（零值根据对象类型不同也不同，这就是为什么对象的实例字段在Java代码中不用初始化也可以使用），若使用TLAB，则这一步可以提前至TALB分配时进行。

##### 4.设置对象头

接下来是对象头的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄信息等。这些信息都存放在对象的对象头中。

##### 5.init初始化

前面几步执行后，在虚拟机角度一个对象已经创建完成了，但是在Java程序角度对象的创建才刚开始，因为init方法还没执行。所以一般来说执行new指令后还会执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来了。

#### 9.Java对象的内存布局

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域，`对象头（Header）`、`实例数据（InstanceData）`、`对齐填充（Padding）`。

`对象头`又包括两部分.

第一部分用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向锁线程ID，偏向时间戳等，官方称为`MarkWord`.

另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

如果是数组对象，那么对象头中还必须有一块用于记录数组长度的数据。

`实例数据`部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。

`对齐填充`没有特殊含义，只是起着占位符的作用，由于HotSpotVM的自动内存管理系统要求对象其实地址必须是8字节的整数倍，也就是对象大小必须是8字节的整数倍，其中对象头大小刚好是8字节的倍数，所以如果对象实例数据部分不是8字节的倍数时就需要对齐填充字节来补全。

#### 10.对象的访问定位

目前主流的访问对象的方式有两种，`句柄`和`直接指针`。

##### 1.句柄

使用句柄的话，会在Java堆中划分一块内存作为`句柄池`,reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各种的具体地址信息。

##### 2.直接指针

如果使用直接指针，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。

##### 3.总结

使用句柄访问的好处是reference中存储的是稳定的句柄，在对象被移动时(垃圾收集时对象被移动是很普遍的）只会改变句柄中的实例数据指针，而reference本身不需要修改。

使用直接指针访问的方式最大的好处就是速度更快，因为节省了一次指针定位的时间开销。

Sun HotSpot虚拟机中使用的是直接指针访问。

#### 11实战OOM异常

## 第三章 垃圾收集器与内存分配策略

### 1.再谈引用

* 强引用(Strong Reference)： 类似`Object o =new Object()`这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
* 软引用(Soft Reference)： 用来描述一些还有用但并非必需的对象，在系统将要发生内存溢出异常之前，会将软引用对象回收，如果这次回收后还没有足够内存才抛出异常。
* 弱引用(Weak Reference)：也是用来描述非必需对象的，只是强度比软引用还低，垃圾收集器工作时，无论内存是否足够都会回收掉弱引用对象。
* 虚引用(Phantom Reference)：它是最弱的一种引用，一个对象是否有虚引用存在，不会对其生存时间构成影响，也无法通过虚引用得到一个实例。`设置虚引用的唯一目的就是在这个对象被回收后得到一个通知。`

### 2.对象回收

即使在可达性分析箅法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。

**要真正宣告一个对象死亡，至少要经历两次标记过程：**

**第一次标记：**

如果对象在进行可达性分析后发现`没有与GCRoots相连接的引用链`，那它将`会被第一次标记`并且进行一次`筛选`.

> 筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。

如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做`F-Queue`的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去`执行`它。

> 这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。

finalize()方法是对象逃脱死亡命运的最后一次机会。

**第二次标记**

稍后GC将对F-Queue中的对象进行第二次小规模的标记.

> 如果对象要在finalize()中成功拯救自己——只要重新与引用链上的对象进行关联，譬如自己（this关键字）赋值给某个变量或对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合。

如果对象没能成功逃脱，那基本上就真的被回收了。

### 3.finalize()方法

需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩.并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，`因为它不是C/C++中的析构函数`，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。`它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序`。有些教材中描述它适合做“关闭外部资源”之类的工作，这完全是对这个方法用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以`建议大家完全可以忘掉Java语言中有这个方法的存在`。

1. finalize的作用

- finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。
- finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性
- 不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。其原因可见下文[finalize的问题]

2. finalize的问题

- 一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如System.runFinalizersOnExit()方法、Runtime.runFinalizersOnExit()方法
- System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们
- Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行
- finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行
- 对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的
- finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为)

3. finalize的执行过程(生命周期)

(1) 首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。

(2) 具体的finalize流程：

对象可由两种状态，涉及到两类状态空间，一是终结状态空间 F = {unfinalized, finalizable, finalized}；二是可达状态空间 R = {reachable, finalizer-reachable, unreachable}。各状态含义如下：

- unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的
- finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行
- finalized: 表示GC已经对该对象执行过finalize方法
- reachable: 表示GC Roots引用可达
- finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达
- unreachable：对象不可通过上面两种途径可达

状态变迁图：

![img](http://img.blog.csdn.net/20131006163937765)

变迁说明：

1. 新建对象首先处于[reachable, unfinalized]状态(A)
2. 随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态
3. 若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。
4. 在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N)
5. 处于finalizable状态的对象不能同时是unreahable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因
6. 程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为
7. 若JVM检测到finalized状态的对象变成unreachable，回收其内存(I)
8. 若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O）
9. 注：System.runFinalizersOnExit()等方法可以使对象即使处于reachable状态，JVM仍对其执行finalize方法。

参考：`https://www.cnblogs.com/Smina/p/7189427.html`

**小结**

当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。

### 4.回收方法区

Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%〜95%的空间，而永久代的垃圾收集效率远低于此。

  永久代的垃圾收集主要回收两部分内容：`废弃常量`和`无用的类`。回收废弃常最与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是`没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量`，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。

  判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：

* 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。

* 加载该类的ClassLoader已经被冋收。

* 该类对应的java.lang.Class对象没冇在任何地方被引用，无法在任何地方通过反射访 问该类的方法。

  虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数迸行控制，还可以使用-verbose:class 以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading类加载和卸载信息，其中-veiboscxlass和-XXi+TraceClassLoading可以在Product版的虚拟机中使用-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。
​    在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

### 5.垃圾收集算法

#### 1.标记-清除算法

最基础的垃圾收集算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成之后统一回收掉所有被标记的对象。

**缺点：**1.效率问题，标记和清除效率都不高。

​	    2.空间问题其次，标记清除之后会产生大量的不连续的内存碎片，空间碎片太多会导致后续当程序需要为较大对象分配内存时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

#### 2.复制算法

为了解决效率问题，“复制”收集算法出现了。

将可用内存按容量分成大小相等的两块，每次只使用其中一块，当这块内存使用完了，就将还存活的对象复制到另一块内存上去，然后把使用过的内存空间一次清理掉。这样使得每次都是对其中一块内存进行回收，内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

**缺点：**可使用的内存降为原来一半。

#### 3.标记-整理算法

标记-整理算法在标记-清除算法基础上做了改进，标记阶段是相同的标记出所有需要回收的对象，在标记完成之后不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，在移动过程中清理掉可回收的对象，这个过程叫做整理。

标记-整理算法相比标记-清除算法的优点是内存被整理以后不会产生大量不连续内存碎片问题。

#### 4.分代收集算法

根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

**新生代**：**复制算法 **

​		每次收集都会有大量对象死去，所以可以选择复制算法，将存活的对象复制到空白的Survivor区，然后清理Eden 区和另外一个Survivor区就可以了。只需要付出少量对象的复制成本就可以完成每次垃圾收集

**老年代**：**标记-整理”算法**

​		老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保,所以采用标记-整理算法。

### 6.垃圾收集器

#### 1.简介

一共7种垃圾收集器。其中年轻代3种，老年代3种。最后一种可以回收年轻代和老年代。

年轻代：Serial  、  ParNew、  Parallel scavenge

老年代：SerialOld 、Concurrent Mark Swap(CMS) 、 ParallelOld

最后一种Garbage First。

其中年轻代和老年代垃圾收集器都是搭配工作的。

CMS可以和Serial、ParNew搭配

SerialOld可以和Serial  、  ParNew、  Parallel scavenge搭配

ParallelOld只能和Parallel scavenge搭配



注意：

这里会接触到几款并发和并行的收集器。两个名词：并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。

* 并行（Parallel):指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
* 并发（Concurrent):指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。

#### 2.Serial收集器

Serial收集器是最基本、发展历史最悠久的收集器。是单线程的收集器。它在进行垃圾收集时，必须暂停其他所有的工作线程(**Stop The Word**)，直到它收集完成。 

Serial收集器依然是虚拟机运行在**Client模式**下默认新生代收集器，对于运行在Client模式下的虚拟机来说是一个很好的选择。 

**新生代采用复制算法，老年代采用标记-整理算法。** 

#### 3.ParNew收集器

ParNew收集器其实就是**Serial收集器的多线程版本**，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The Worl、对象分配规则、回收策略等都与Serial 收集器完全一样 

它是许多运行在**Server模式**下的虚拟机的首要选择，除了性能原因之外，目前除去Serial收集器，只有ParNew收集器能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。

在单CPU甚至两个CPU的环境下，ParNew收集器都不能百分百得保证性能比serial收集器性能高，但是随着CPU数量的增加，它对于GC时系统资源的有效利用还是有好处的。

**新生代采用复制算法，老年代采用标记-整理算法。**

#### 4.Parallel Scavenge收集器

Parallel Scavenge 收集器类似于ParNew 收集器。 **那么它有什么特别之处呢？**

```java
-XX:+UseParallelGC 
    //使用Parallel收集器+ 老年代串行
-XX:+UseParallelOldGC
    //使用Parallel收集器+ 老年代并行
```

**Parallel Scavenge**收集器关注点是**吞吐量**（高效率的利用CPU）。**CMS**等垃圾收集器的关注点更多的是**用户线程的停顿时间**（提高用户体验）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）

**新生代采用复制算法，老年代采用标记-整理算法。**

#### 5.Serial Old收集器

**Serial收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。

#### 6Parallel Old收集器

**Parallel Scavenge收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。

#### 7.CMS收集器

**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。**

从名字中的**Mark Sweep**这两个词可以看出，CMS收集器是一种 **“标记-清除”**算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；

- **并发标记：** 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。

- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短

- **并发清除：** 开启用户线程，同时GC线程开始对为标记的区域做清扫。

  初始标记、重新标记这两个步骤仍然需要“Stop The World”. 

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对CPU资源敏感，垃圾收集时会占用大量CPU资源**
- **无法处理浮动垃圾，即并发标记时用户线程继续运行时产生的垃圾，只能等下一次垃圾回收才能处理**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

#### 8.G1收集器

**G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.**

**G1收集器的优势：**

（1）并行与并发，可以充分利用多CPU，多核环境优势来缩短Stop-The-World停顿时间。

（2）分代收集，不需要与其他收集器配合就能管理整个GC堆。

（3）空间整理 （标记整理算法，复制算法），不会产生内存空间碎片。

（4）可预测的停顿（G1处处理追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经实现Java（RTSJ）的来及收集器的特征）

**大致步骤：**

（1）初始标记

（2）并发标记

（3）最终标记

（4）筛选回收

**G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)**。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。 

> G1用于堆比较大的应用上，GC 的时间难以预估的这种效果更好，内存200G以上，JDK9（含）以上，jdk版本较低的G1功能有欠缺 

