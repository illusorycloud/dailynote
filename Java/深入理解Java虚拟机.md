# 深入理解Java虚拟机

## 第一章 走进Java

### 展望Java技术的未来

模块化

混合语言 项目中每个应用层使用不同的需要，发挥各自的优点，中间层使用Java。

多核并行 

进一步丰富语法  

64位虚拟机

## 第二章 自动内存管理机制

### 2.1 运行时数据区

#### 1.程序计数器   

线程独立的。可以看做是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

#### 2.java虚拟机栈

生命周期和线程相同，线程独立。每个方法在执行时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到执行完成的过程就是一个栈帧在虚拟机中的入栈到出栈的过程。

局部变量表：存放了编译时期可知的各种基本类型（Boolean，byte，char,short,int.float.long,double）、对象引用（reference类型）和returnAddress（指向了一条字节码指令的地址）

#### 3.本地方法栈

和Java虚拟机栈作用相似，不过这是为虚拟机执行Native方法服务的，线程独立的。

#### 4.堆

Java堆是虚拟机所管理的内存中最大的一块了。线程共享，在虚拟机启动时创建。也是垃圾回收的主要区域。Java虚拟机规范中说的是：所有的对象实例以及数组都要在堆上分配内存。但是随着`JIT(just in time)编译器`的发展与`逃逸分析`技术的成熟，`栈上分配`，`标量替换`优化技术将会导致一些微妙的变化，所有对象都分配在堆上也变得不是那么绝对了。

垃圾回收器都采用分代回收算法。所以Java堆可以细分为`新生代`和`老年代`。在细致一点可以分为`Eden空间`，`From Survivor`,`To Survivor`等。

#### 5.方法区

也是线程共享的区域。用于存储已被虚拟机加载的`类信息`,`常量`，`静态变量`，`即时编译器编译后的代码`等数据。

java虚拟机把方法区描述为堆的一个逻辑区域，但是方法区却有一个别名`Non-Heap非堆`目的应该是和Java堆区分开。

#### 6.运行时常量池

`运行时常量池`是`方法区`的一部分。Java Class文件中除了有类的版本，字段，方法，接口等描述信息外还有一项信息是`常量池`,用于存放编译期生成的各种`字面量`和`符号引用`，这部分内容将在`类加载后`进入方法区的`运行时常量池`。

##### 全局字符串池

全局字符串池里的内容是在类加载完成，经过验证，**准备阶段之后**在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。

##### class文件常量池（class constant pool）

Java Class文件中除了有类的版本，字段，方法，接口等描述信息外还有一项信息是`常量池`,用于存放编译期生成的各种`字面量`和`符号引用`，这部分内容将在`类加载后`进入方法区的`运行时常量池`。

 字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。 符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

##### 运行时常量池

jvm在执行某个类的时候，必须经过`加载`、`连接`、`初始化`，而连接又包括`验证`、`准备`、`解析`三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，`运行时常量池也是每个类都有一个`。在上面我也说了，`class常量池中存的是字面量和符号引用`，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过`解析（resolve）`之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。

##### 小结

- 1.全局常量池在每个VM中只有一份，存放的是字符串常量的引用值。
- 2.class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。
- 3.运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。

#### 7.直接内存

直接内存并不是虚拟机运行时数据区的一部分，但是也频繁被用到，也可能导致OOM,虚拟机内存+直接内存超过物理内存时。

在JDK1.4出现的NIO类中引入了一个基于Channel和Buffer的IO方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，能在一些场合中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

#### 8.对象的创建

##### 1.类加载检查

虚拟机遇到new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过。若没有则必须先执行相应的类加载过程。

##### 2.分配内存空间

在类加载检查完成后，接下来虚拟机开始为新生对象分配内存，对象所需内存大小在类加载完成后即可完全确定。

**问题：**

这里有一个问题就是对象创建在虚拟机中是非常频繁的，并发情况下可能会有线程安全问题。可能出现正在给对象A分配内存，指针还没来得及修改，对象B又使用的原来的指针来分配内存。

**解决方案：**

有两种解决方案。

一种是对分配内存空间的动作进行同步处理----实际上虚拟机采用CAS配上失败重试的方式，保证更新操作的原子性。

另一种是把内存分配的动作放在不同的空间中进行，即每个线程在Java堆中预先分配一块内存，称为本地线程分配缓冲TLAB（Thread Local Allocation Buffer），分配内存时优先在线程自己的TALB上分配，因为`在TLAB上分配对象时不需要加锁`，只有TALB用完后分配新的TALB时才需要同步锁定。

##### 3.初始化零值

内存分配完成后，虚拟机将分配到的内存空间都初始化为零值（零值根据对象类型不同也不同，这就是为什么对象的实例字段在Java代码中不用初始化也可以使用），若使用TLAB，则这一步可以提前至TALB分配时进行。

##### 4.设置对象头

接下来是对象头的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄信息等。这些信息都存放在对象的对象头中。

##### 5.init初始化

前面几步执行后，在虚拟机角度一个对象已经创建完成了，但是在Java程序角度对象的创建才刚开始，因为init方法还没执行。所以一般来说执行new指令后还会执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来了。

#### 9.Java对象的内存布局

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域，`对象头（Header）`、`实例数据（InstanceData）`、`对齐填充（Padding）`。

`对象头`又包括两部分.

第一部分用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向锁线程ID，偏向时间戳等，官方称为`MarkWord`.

另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

如果是数组对象，那么对象头中还必须有一块用于记录数组长度的数据。

`实例数据`部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。

`对齐填充`没有特殊含义，只是起着占位符的作用，由于HotSpotVM的自动内存管理系统要求对象其实地址必须是8字节的整数倍，也就是对象大小必须是8字节的整数倍，其中对象头大小刚好是8字节的倍数，所以如果对象实例数据部分不是8字节的倍数时就需要对齐填充字节来补全。

#### 10.对象的访问定位

目前主流的访问对象的方式有两种，`句柄`和`直接指针`。

##### 1.句柄

使用句柄的话，会在Java堆中划分一块内存作为`句柄池`,reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各种的具体地址信息。

##### 2.直接指针

如果使用直接指针，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。

##### 3.总结

使用句柄访问的好处是reference中存储的是稳定的句柄，在对象被移动时(垃圾收集时对象被移动是很普遍的）只会改变句柄中的实例数据指针，而reference本身不需要修改。

使用直接指针访问的方式最大的好处就是速度更快，因为节省了一次指针定位的时间开销。

Sun HotSpot虚拟机中使用的是直接指针访问。

#### 11实战OOM异常

## 第三章 垃圾收集器与内存分配策略

### 1.再谈引用

* 强引用(Strong Reference)： 类似`Object o =new Object()`这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
* 软引用(Soft Reference)： 用来描述一些还有用但并非必需的对象，在系统将要发生内存溢出异常之前，会将软引用对象回收，如果这次回收后还没有足够内存才抛出异常。
* 弱引用(Weak Reference)：也是用来描述非必需对象的，只是强度比软引用还低，垃圾收集器工作时，无论内存是否足够都会回收掉弱引用对象。
* 虚引用(Phantom Reference)：它是最弱的一种引用，一个对象是否有虚引用存在，不会对其生存时间构成影响，也无法通过虚引用得到一个实例。`设置虚引用的唯一目的就是在这个对象被回收后得到一个通知。`

### 2.对象回收

即使在可达性分析箅法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。

**要真正宣告一个对象死亡，至少要经历两次标记过程：**

**第一次标记：**

如果对象在进行可达性分析后发现`没有与GCRoots相连接的引用链`，那它将`会被第一次标记`并且进行一次`筛选`.

> 筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。

如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做`F-Queue`的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去`执行`它。

> 这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。

finalize()方法是对象逃脱死亡命运的最后一次机会。

**第二次标记**

稍后GC将对F-Queue中的对象进行第二次小规模的标记.

> 如果对象要在finalize()中成功拯救自己——只要重新与引用链上的对象进行关联，譬如自己（this关键字）赋值给某个变量或对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合。

如果对象没能成功逃脱，那基本上就真的被回收了。

**finalize()方法**

需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩.并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，`因为它不是C/C++中的析构函数`，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。`它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序`。有些教材中描述它适合做“关闭外部资源”之类的工作，这完全是对这个方法用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以`建议大家完全可以忘掉Java语言中有这个方法的存在`。

**小结**

当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。