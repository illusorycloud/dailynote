# 简单说说类加载过程，里面执行了哪些操作？

**类的生命周期：加载-->连接（验证，准备，解析）-->初始化-->使用-->卸载**

类加载过程 :加载-->连接（验证，准备，解析）

## 1.加载

* 1) 通过类型的完全限定名，产生一个代表该类型的二进制数据流（根本没有指明从哪里获取、怎样获取，可以说一个非常开放的平台了）

* 2) 解析这个二进制数据流为方法区内的运行时数据结构

* 3) 创建一个表示该类型的java.lang.Class类的实例，作为方法区这个类的各种数据的访问入口。

```
类加载器的任务就是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例。
BootstrapClassLoader、ExtClassLoader和AppClassLoader
defineClass方法将字节码的byte数组转换为一个类的class对象实例，如果希望在类被记载到JVM时就被链接，那么可以调用resolveClass方法。
```

```
简单的说，类加载阶段就是由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例（Java虚拟机规范并没有明确要求一定要存储在堆区中，只是hotspot选择将Class对戏那个存储在方法区中），这个Class对象在日后就会作为方法区中该类的各种数据的访问入口。
```

## 2. 验证

为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 

从整体上看，验证阶段大致上会完成4个阶段的校验工作：**文件格式、元数据、字节码、符号引用**。 

```
验证类数据信息是否符合JVM规范，是否是一个有效的字节码文件，验证内容涵盖了类数据信息的格式验证、语义分析、操作验证等。
格式验证：验证是否符合class文件规范
语义验证：检查一个被标记为final的类型是否包含子类；检查一个类中的final方法视频被子类进行重写；确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）
操作验证：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执行，检查是否通过富豪引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等）
```

## 3. 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。

```
为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内）
被final修饰的静态变量，会直接赋予原值；类字段的字段属性表中存在ConstantValue属性，则在准备阶段，其值就是ConstantValue的值
```

初始值通常是数据类型的零值 :

```java
boolean----->false
char----->null
byte/short/int/long---->0
float/double----->0.0
//引用类型数据的默认值也为空(null)
```

## 4. 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 

```
将常量池中的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。
可以认为是一些静态绑定的会被解析，动态绑定则只会在运行是进行解析；静态绑定包括一些final方法(不可以重写),static方法(只会属于当前类)，构造器(不会被重写)
```

**符号引用(Symbolic References)：** 符号引用以一组符号来描述所引用的目标 .

**直接引用（Direct References）:** 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。 

## 5. 初始化

类初始化阶段是类加载的最后一步，到这儿才真正开始执行类中定义的java程序代码（或者说是字节码）。

```
将一个类中所有被static关键字标识的代码统一执行一遍，如果执行的是静态变量，那么就会使用用户指定的值覆盖之前在准备阶段设置的初始值；如果执行的是static代码块，那么在初始化阶段，JVM就会执行static代码块中定义的所有操作。
所有类变量初始化语句和静态代码块都会在编译时被前端编译器放在收集器里头，存放到一个特殊的方法中，这个方法就是<clinit>方法，即类/接口初始化方法。该方法的作用就是初始化一个中的变量，使用用户指定的值覆盖之前在准备阶段里设定的初始值。任何invoke之类的字节码都无法调用<clinit>方法，因为该方法只能在类加载的过程中由JVM调用。
如果父类还没有被初始化，那么优先对父类初始化，但在<clinit>方法内部不会显示调用父类的<clinit>方法，由JVM负责保证一个类的<clinit>方法执行之前，它的父类<clinit>方法已经被执行。
JVM必须确保一个类在初始化的过程中，如果是多线程需要同时初始化它，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。
```

## 参考

`深入理解Java虚拟机`

`http://blog.csdn.net/u013256816/article/details/50829596`

`http://blog.csdn.net/zhoudaxia/article/details/35824249`

`https://www.cnblogs.com/xiaoxian1369/p/5498817.html`