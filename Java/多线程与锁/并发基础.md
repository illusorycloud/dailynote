# 并发基础

## 1.Synchronize

**一个线程在获取到监视器锁以后才能进入 synchronized 控制的代码块，一旦进入代码块，首先，该线程对于共享变量的缓存就会失效，因此 synchronized 代码块中对于共享变量的读取需要从主内存中重新获取，也就能获取到最新的值**。

**退出代码块的时候的，会将该线程写缓冲区中的数据(synchronized代码块中有写过的共享变量)刷到主内存中**，所以在 synchronized 代码块之前或 synchronized 代码块中对于共享变量的操作随着该线程退出 synchronized 块，会立即对其他线程可见（这句话的前提是其他读取共享变量的线程会从主内存读取最新值）。

**线程 a 对于进入 synchronized 块之前或在 synchronized 中对于共享变量的操作，对于后续的持有监视器锁的线程 b 可见**。

## 2.Volatile

**内存可见性和禁止指令重排序。**

volatile 有类似的语义，读一个 volatile 变量之前，需要先使相应的本地缓存失效，这样就必须到主内存读取最新值，写一个 volatile 属性会立即刷入到主内存。所以，volatile 读和 monitorenter 有相同的语义，volatile 写和 monitorexit 有相同的语义。

## 3.final 关键字

在对象的构造方法中设置 final 属性，**同时在对象初始化完成前，不要将此对象的引用写入到其他线程可以访问到的地方**（不要让引用在构造函数中逸出）。如果这个条件满足，当其他线程看到这个对象的时候，那个线程始终可以看到正确初始化后的对象的 final 属性。

**final 属性的写操作不会和此引用的赋值操作发生重排序**