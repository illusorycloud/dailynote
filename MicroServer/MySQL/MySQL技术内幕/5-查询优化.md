# MySQL查询优化

## 1. 使用索引

加速查询的技术很多，其中最重要的就是索引。
MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。

### 1. 如何挑选索引
**1.为用于搜索、排序或分组的列创建索引，而对于用作输出显示的列则不用创建索引。**

```mysql
SELECT col_a # 不是候选列
FROM
	tbl1 LEFT JOPIN tbl2
	ON tbl1.col_b = tbl2.col_c #候选列
WHERE col_d =expr # 候选列
```



**2.认真考虑数据列基数**

列的基数指它所容纳的所有非重复值的个数。相对于表里行的总数来说列的基数越高索引的使用效果越好。

> 如果列中只包括两个值`F`和`M`,那么索引操作毫无用处。

```mysql
SELECT COUNT(*),COUNT(DISTINCT col_name) FROM tbl_name;
```



**3.索引短小值**

尽量选用比较小的数据类型，较短小的值可以在以下几方面提高索引的处理性能：

* 1.短小值可以让比较操作更快，从而加快索引查找速度
* 2.短小值可以让索引短小，从而减少对磁盘I/O请求
* 3.对于更短小的键值，键缓存力量的索引快可以容纳更多的键值。如果MySQL能在内存里同时容纳更多的键，那么就可以在不从磁盘读取更多索引块的前提下提高找到键的记录。

对于InnoDB存储引擎，因为它使用的是聚簇索引，所以让主键尽量短小会带来很多好处。聚簇索引会把数据行和主键值存储在一起(即聚集在一起)，其他的索引都是二级索引，即它们把主键值和二级索引存储在一起，在二级索引里面进行查找会先得到主键值然后再通过主键值定位到相应的行。这意味着主键值在每一个二级索引里都会重复出现，因此如果主键值较长，会导致每一个二级索引需要占用更多的存储空间。

**4.索引字符串值得前缀**

想要对字符串列进行索引，应当尽可能指定前缀长度。



**5.利用最左前缀**

当创建包含N个列的复合索引时，实际上会创建N个专供MySQL使用的索引。复合索引相当于多个索引，因为索引中最左边的任意数据列集合都可用于匹配各个行。这样的索引即为`最左前缀`(这和对列的前缀进行索引不同).

对于一个包含`a,b,c`三列的复合索引可以看成是`a b c`、`a b`、`a c`、和`a`这4个索引。

**6.不要建立过多的索引**

索引不是越多越好，每增加一个索引都要占据额外的磁盘空间，而且会影响写入操作。



**7.让参与比较的索引类型保持匹配**

在创建索引时大部分存储引擎会选择它们要使用的索引实现。

对于InnoDB总会使用B数索引，MyISAM也会使用B数索引，但是对于空间类型则会改用R数索引。

在选择索引类型时请考虑计划在索引列上执行的是什么类型的比较操作。



对于精确匹配的比较操作来说散列索引速度非常快，但是用于查找一个范围内的值的比较操作里却表现欠佳。

对于精确比较或范围比较是使用B数索引会带来高效。
指定索引类型可以在索引定义里加上`USING BTREE`指定使用B树索引其他索引同理。

**8.利用慢查询日志找出性能低劣的查询**

这个日志可以帮助我们找出低性能的查询，当然这个慢是相对的，相比于低负载，服务器处于高负载时会出现更多慢查询。



## 2. MySQL查询优化程序

在调用语句时MySQL会先对他进行分析，判定出可以使用哪些优化操作来加快处理速度。

例如下面这条语句不管表多大都会执行得非常快

```mysql
EXPLAIN SELECT * FROm tbl_name WHERE FALSE;
```

对于上述查询，MySQL会先检查WHERE子句，并没有发现符合条件的行，因此根本不会去搜索这个表。

可以使用EXPLAIN关键字查询分析过程,

```mysql
EXPLAIN SELECT * FROm tbl_name WHERE FALSE;
```



### 1. 工作原理

优化程序有几个目标，主要目标是尽可能使用索引，并且使用最严格的索引来消除对行数量随时可能快速增加的顾虑。

```mysql
SELECT col3 FROM mytable
WHERE col1='some value' col2='some other value';
```

假设`col1='some value'`会匹配到1000行，`col2='some other value'`会匹配到300行，而两个条件加起来则会匹配到30行。

那么为了这30行会先匹配1000行然后在过滤掉970行，如果是先匹配col2的300行则只需要过滤掉270行。索引优化器会选择先匹配col2.



**1. 分析表**

这将生成关于键值分布情况的统计数据，它们可以帮助优化程序准确地评估索引效率。

**2.使用EXPLAIN验证优化程序的操作**

使用EXPLAIN语句可以了解到各个索引是否被使用到。



**3.在必要时给与优化程序提示或改写它**

在连接操作的表列表里，可以在表名后面加上FORCE INDEX、USE INDEX、IGNORE INDEX以告知服务器期望使用哪些索引。



**4.比较拥有相同数据类型的列**

在对带有索引的列进行比较时，如果数据类型相同那么与类型不同的情况相比查询性能会提高很多。

**5.让索引列在比较表达式中单独出现**

如果在函数中调用了列或者将列当做是复杂表达式的一部分那么MySQL将不会使用该索引，因为它必须计算每一行的表达式值。

**6.不要在LIKE模式的开始使用通配符**

例如
```mysql
WHERE col_name LIKE '%string%'
```
如果想把无论是否出现在该列里的所有字符串都找出来，那么这个子句是正确的。但是不要习惯性地将`%`放在字符串的两侧。假设在包含姓的列中查询以`Mac`开头的 那么可以写成
```mysql
WHERE last_name LIKE 'Mac%'
```
优化器会查看这个模式的文字初始部分，并使用索引来找到匹配的行，跟下面编写的表达式一样，会用到last_name的索引
```mysql
WHERE last_name >= 'Mac' AND last_name < 'Mad'
```

这种优化方式不能用于使用REGEXP运算符的模式匹配，因为REGEXP表达式绝不会被优化。

**7.利用优化查询的长处**

MySQL支持连接和子查询，但是优化程序在许多场合对连接的优化效果要不子查询更好一些。



**8. 测试查询的各种替代形式并多次运行它们**

当测试查询的各种替代形式需要对每种形式都反复多次运行，如果都运行一次那么后面运行的那种通常会更快，因为第一次查询的信息仍然保留在磁盘的高速缓存内，不需要从磁盘里读取。



**9.避免过多使用自动类型转换**

MySQL可以实现类型的自动转换，但是如果避免这类转换则可能获得更好的性能。

### 2.使用EXPLAIN检查优化程序的操作

EXPLANIN语句提供的信息有助于我们了解优化程序为处理各种语句而生成的执行计划。



EXPLAIN语句可以让我们了解到以何种方式编写表达式才会更优。

同时也能验证增加索引能否帮助优化程序更有效地执行某条语句。



## 3. 选择有利于高效查询的数据类型

对数据类型的选择，会在许多方面影响查询性能。

**多用数字运算，少用字符串运算**

数字运算通常比字符串运算更快。

**当较小类型够用时就不用较大类型**
MySQL处理较小类型输的比较大类型快。尤其是字符串处理时间与长度有直接关系。
同时选用较小类型可以让整个表变得更小，从而减少在磁盘读写方面的开销。
**将数据列声明成NOT NULL**
如果数据列为NOT NULL，那么MySQL对它的处理速度也会更快，因为在查询处理期间不需要在检查该列的值是否为NULL。
**考虑使用ENUM列**
如果字符串列的基数低可以考虑转换成ENUM列。
**使用PROCEDURE ANALYSE()**
运行 PROCEDURE ANALYSE()可以看到许多关于表里各列的信息
```mysql
SELECT * FROM tbl_name PROCEDURE ANALYSE()
```
**整理表碎片**
对于频繁修改的表，尤其是包含可变长度数据列的表，往往会产生大量碎片。会造成存储表的磁盘空间的浪费，会导致每次必须读取更多的磁盘块才能找到有效的行。
定期试验OPTIMIZE TABLE可以消除或减少碎片化的MyISAM或InnoDB表里的空间浪费。

**把数据压缩到BLOB或者TEXT列**
使用BLOB或TEXT列来存储那些可以在应用程序里对其进行压缩和解压缩的数据，能达到使用单个检索操作找出所有的内容。

**使用合成索引**
合成索引列有时很有用，一种做法是先根据表里的其他列计算出一个散列值，把它存储到单独的列里，然后通过散列值来检索行。
**避免检索很大的BLOB或者TEXT值**
比如在有确定`WHERE`子句限制的时候才使用`SELECT *`
**把BLOB或TEXT列剥离出来形成单独的表**
某些情况下这样可能会更有意义。

## 4. 选择利于高效查询的表存储格式

有些存储引擎实现了多种存储格式，每一种都有自己的性能特性。

例如MyISAM引擎处理固定长度列会比可变长度列快，但是InnoDB引擎从则处理这两个都差不多。

默认情况下InnoDB会使用COMPACT行格式，这种选择适合于大部分的情形。

对于包含重复数据的表，使用COMPRESSED行格式能带来更多的好处，这种表占用的空间更少，会节省读取数据的时间。

对于带有长BLOB或TEXT值得表，DYNAMIC行格式最有效。



格式如下

```mysql
CREATE TABLE t1() ENGINE = InnoDB ROW_FORMAT=COMPRESSED;
```

修改已有表格式

```mysql
ALTER TABLE t1 ROW_FORMAT=DYNAMIC;
```



## 5. 高效写入数据

相比之下大家更关心SELECT语句的优化，不过写入数据还是可以进行优化的，让数据能够更快的写入数据库。

* 1.把数据从环城刷新到磁盘的次数越少那么数据写入就越快。

因此批量写入就会比单条写入快，批量写入时会先缓存然后一次性写入磁盘，单条写入则会多次写入磁盘所以很慢。

* 2.表的索引越少写入速度越快

写入数据时不光只写入数据，如果有索引还要同步更新索引，所以索引不是越多越好。

* 3.于长SQL语句相比，短语句的数据写入速度更快。

因为短语句在服务器上的解析操作会更少，并且会更快的从客户端发送到服务器上去执行。

## 6. 调度、锁定和并发

MySQL的调度策略总结如下：

* 1.写入优先级比读取高
* 2.表的写入操作一次只能进行一个，多个写入按请求到达的先后顺序依次处理
* 3.可以同时处理多个对同一个表的读取操作

InnoDB存储引擎利用行级锁实现这种调度策略，但是InnoDB只有在必要时才会锁定行。

另外的MyISAM MERGE MEMORY存储引擎则使用了表级锁，就竞争管理而言具有完全不同的特征，只要客户端访问表就必须先锁定，当这个客户端完成了对表的操作时才会接触锁定。
执行`LOCK TABLES`和`UNLOCK TABLE`可以显式地获得和接触锁定。


把数据写入表，客户端需要具有对表进行互斥访问的锁定，不允许其他客户端进行写或者读。
从表里读取数据，客户端必须锁定它，以防止其他客户端在这个时候写入或者修改数据，但是这个操作不需要互斥访问，可以让其他客户端同时读取表里的数据。