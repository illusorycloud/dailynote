# 索引与算法

## 1. InnoDB存储引擎索引

 InnoDB常见索引：B+树索引、全文索引、哈希索引

B+树索引就是传统意义上的索引，B+树索引并不能找到一个给定的键值的具体行，只能找到数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查找，得到最后所要查找的数据。



## 2. B+树索引

B+树索引在数据库中的一个特点是高扇出性，因此一般B+树的高度是2~4层。B+树索引可以分为：聚集索引、辅助索引。

### 1. 聚集索引

聚集索引是按照每张表的主键构造的B+树，同时叶子节点存放的就是整张表的行记录数据，聚集索引的叶子节点就是数据页。每个数据页是通过双向链表来进行链接的。

一张表只能有一个聚集索引。

多数情况下，查询优化器倾向采用聚集索引。因为聚集索引能在B+树索引的叶子节点上直接找到数据。此外，由于定义了数据的逻辑顺序，聚集索引能够很快的访问针对范围的查询。

数据页上存放的是完整的每行记录，而在非数据页的索引中存放的是键值以及指向数据页的偏移量。

聚集索引在逻辑上是连续的。对于主键的排序查找和范围查找速度非常快。



### 2. 辅助索引

辅助索引的存在不影响聚集索引的组织，每张表可以有多个辅助索引。



例如：

如果在一棵高度为3的辅助索引树中查找数据，那需要进行3次查找找到主键，然后在对聚集索引进行查找，如果聚集索引数高度为3则也需要进行3次查找，最终找到一个完整的行数据所在的页。

因此一共需要6次逻辑IO访问以得到最终的一个数据页。



## 3. Cardinality值

### 1.  什么是Cardinality

Cardinality表示索引汇总不重复记录数量的预估值，在实际应用中`Cardinality/n_rows_in_table`应该尽可能接近1。

可以简单理解为列中数据的可选择性。

 并不是在所有查询条件中出现的列都需要添加索引。

* 低选择性：对于像性别、类型、地区这样的，他们的取值范围很小，称为低选择性。
* 高选择性：某个字段的取值范围很广，几乎没有重复的。高选择性最适合使用B+树索引。



### 2. InnoDB存储引擎的Cardinality统计

数据库对于Cardinality的统计是通过`采样`的方法来完成的。Cardinality统计信息的更新发生在insert、update这两个操作中。

InnoDB对Cardinality更新的策略是：

* 1.表中的1/16的数据已经发生了改变；
* 2.stat_modified_counter>20亿



  InnoDB默认对8个叶子节点进行采样,采样过程：

* 1.采取B+树索引中叶子节点的数量A；
* 2.随机抽取B+树索引中的8个叶子节点，统计每个数据页不同记录数P1,P2……P8；
* 3.根据采样信息计算Cardinality预估值：Cardinality=（P1+P2+……+P8）*A/8



## 4. B+树索引的使用

### 1. 联合索引

 联合索引指的是对表上的多个列进行索引。联合索引的键值是大于1的。

```mysql
CREATE TABLE t(
	a INT,
    b INT,
    PRIMARY KEY(a),
    KEY idx_a_b(a,b)
)ENGINE = INNODB;
```

主键为a,创建了联合索引idx_a_b，联合的列为(a,b)。



### 2. 覆盖索引

 InnoDB支持覆盖索引（索引覆盖），即从辅助索引中就可以查询到记录，而不需要查询聚集索引中的记录。

辅助索引只会存储索引列的值和主键的值，所以只有刚好查询这几个列的时候才有可能触发覆盖索引。

例如：

在列`name`上创建一个索引，然后主键为`id`。

那么下列查询就会触发覆盖索引

```mysql
SELECT id,name FROM t where id=1;
```

如果再多查询一个列

```mysql
SELECT id,name,age FROM t where id=1;
```

则不会覆盖索引，需要回表，因为在这个索引中age列数据获取不到。

如果这时创建一个(name,age)的联合索引那么又可以触发覆盖索引了。

## 5. 哈希算法

InnoDB使用哈希算法对字典进行查找，冲突解决机制是采用链表方式，哈希函数采用除法散列的方式。



## 6. 全文检索

全文检索：将存储于数据库中的整本书或者整篇文章中的任意内容信息查找出来的技术。

### 1. 倒排索引

全文检索通常使用倒排索引(inverted index)来实现，倒排索引和B+树一样也是一种索引结构。它在辅助表中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。通常利用关联数组实现，有两种表现形式：

* 1.inverted  field index 表现形式为{单词,单词所在的文档ID}
* 2.full inverted index 表现为{单词,(单词所在文档ID,在具体文档中的位置)}



### 2. InnoDB全文检索

InnoDB存储引擎从1.2.X版本开始支持全文检索，采用`full inverted index`的方式。



