# Redis二进制位数组

## 1. 概述

Redis提供了`SETBIT`、`GETBIT`、`BIITCOUNT`、`BITOP`四个命令用于处理二进制位数组。

```sh
#对key所存储的字符串值，获取指定偏移量上的位（bit）
getbit key offset

# 对key所存储的字符串值，设置或清除指定偏移量上的位（bit） 1. 返回值为该位在setbit之前的值 2. value只能取0或1 3. offset从0开始，即使原位图只能10位，offset可以取1000
setbit key offset value

#获取位图指定范围中位值为1的个数 如果不指定start与end，则取所有
bitcount key [start end]

#做多个BitMap的and（交集）、or（并集）、not（非）、xor（异或）操作并将结果保存在destKey中
bitop op destKey key1 [key2...]
```



## 2. 实现

### 1. 位数组表示

Redis中使用字符串对应来表示位数组，因为SDS数据结构是二进制安全的所以程序可以直接使用SDS结构保存数组，并使用相关函数来处理位数组。



### 2. GETBIT

GETBIT 命令用于返回位数组 `bitarray` 在 `offset` 偏移量上的二进制位的值：

```
GETBIT <bitarray> <offset>
```

GETBIT 命令的执行过程如下：

1. 计算`byte = offest/8`， `byte` 值记录了 `offset` 偏移量指定的二进制位保存在位数组的哪个字节。
2. 计算`bit = (offset%8) + 1`， `bit` 值记录了 `offset` 偏移量指定的二进制位是 `byte` 字节的第几个二进制位。
3. 根据 `byte` 值和 `bit` 值， 在位数组 `bitarray` 中定位 `offset` 偏移量指定的二进制位， 并返回这个位的值。

举个例子 命令：

```
GETBIT <bitarray> 3
```

将执行以下操作

* 1.`3/8=0`
* 2.`3%8+1=4`
* 3.定位到buf[0]上取出该字节上的第4个二进制位(从左往右数)的值
* 4.向客户端返回获取到的值



### 3. SETBIT

set命令和get类似

* 1.计算`len = =offest/8+1`,len为保存offset偏移量指定的二进制位至少需要多少字节
* 2.如果SDS长度小于len则扩容为len字节并将新扩展空间的值置为0
* 3.计算`byte = offest/8`， `byte` 值记录了 `offset` 偏移量指定的二进制位保存在位数组的哪个字节。
* 4.计算`bit = (offset%8) + 1`， `bit` 值记录了 `offset` 偏移量指定的二进制位是 `byte` 字节的第几个二进制位。
* 5.根据byte和bit值获取到键中保存的旧值存到`oldvalue`并将新值设置为这个二进制为的值
* 6.向客户端返回旧值`oldvalue`



### 4. BITCOUNT

BITCOUNT返回给定数组中值为1的数量。

**1.遍历法**

实现BITCOUNT最简单的方法，遍历整个位数组，遇到值为1的二进制位时计数加1。

简单但是效率低,对于一个500M的位数组，需要查询40亿次。

**2.查表算法**

对方法一的优化是使用查表法。

对于一个长度有限的集合来说，内部元素的组合排列方式也是有限的，那么对于一个长度有限的位数组来说，他能表示的二进制位排列也是有限的。

所以可以先列出所有的排列组合和对应的值为1的个数，到时候就不需要遍历了，直接查表即可找到个数。

| 键(位数组) | 值(值为1的数量) |
| ---------- | --------------- |
| 0000 0000  | 0               |
| 0000 0001  | 1               |
| ...        | ...             |
| 1111 1111  | 8               |

每次从位数组中拿出8位或者16位然后去查表，这样查询次数可以减少到方法一的8分之一会16分之一了。对于一个500M的位数组，也需要查询5亿次或者2.5亿次，带来的提升任然不够。



**3.variable-precision SWAR算法**

BITCOUNT命令要解决的问题：统计位数组中非0二进制位的数量，在数学上被称为`计算汉明重量(Hamming Weight)`

汉明重量经常被用于信息论、编码理论和密码学，所以研究人员针对汉明重量开发了多种不同的算法。目前已知效率最高的就是`variable-precision SWAR算法`

```c
int SWAR(unsigned int i)
{
    // 步骤1
    x = (x & 0x55555555) + ((x >> 1) & 0x55555555);
    // 步骤2
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    // 步骤3
    x = (x & 0x0f0f0f0f) + ((x >> 4) & 0x0f0f0f0f);
    // 步骤4
    i = (i*(0x01010101) >> 24)
    return i;
}
```

```c
// 奇数位为1 偶数位为0
0x55555555 = 0b01010101010101010101010101010101
```



* 步骤1中每2位为一组，记录了这2位里面非0位的个数
* 步骤2中每4位为一组，记录了这4位里面非0位的个数
* 步骤3中每8位为一组，记录了这8位里面非0位的个数
* 最后32位中1的个数的总数就被保存在了高8位中，此时只需要`>>24`就可以求出来了

当然在实际中，我们可以一次计算出多个32位，比如计算出4*32 那样的时间效率相对于遍历就节约了128倍，相对于查表法也快了4*4倍

**Redis实现**

Redis用到了`查表法`和`SWAR算法`两种。

* 1.如果大于128位则使用SWAR算法计算汉明重量
* 2.如果小于128位则使用查表法来计算汉明重量



### 5. BITOP

因为C语言直接支持对字节执行`逻辑与&`、`逻辑或|`、`逻辑非~`、`逻辑异或^`

所以BITOP命令的`AND`、`OR`、`XOR`、`NOT`都是基于这些实现的。



## 3. 小结

- Redis 使用 SDS 来保存位数组。
- SDS 使用逆序来保存位数组， 这种保存顺序简化了 SETBIT 命令的实现， 使得 SETBIT 命令可以在不移动现有二进制位的情况下， 对位数组进行空间扩展。
- BITCOUNT 命令使用了查表算法和 variable-precision SWAR 算法来优化命令的执行效率。
- BITOP 命令的所有操作都使用 C 语言内置的位操作来实现。