# RedisLua脚本

## 1. 概述

Redis从2.6版本开始引入对Lua脚本的支持。通过在服务器内嵌Lua环境，客户端可以直接使用Lua脚本，在服务端原子地执行多个Redis命令。



`EVAL`命令可以执行执行Lua脚本

`EVALSHA` 可以通过脚本的sha1校验和直接调用缓存中的脚本,前提是脚本被执行过或者调用`SRPIPT LOAD`加载到缓存中了。





## 2. 环境创建

Redis 服务器创建并修改 Lua 环境的整个过程由以下步骤组成：

* 1.创建一个基础的 Lua 环境， 之后的所有修改都是针对这个环境进行的。
* 2.载入多个函数库到 Lua 环境里面， 让 Lua 脚本可以使用这些函数库来进行数据操作。
* 3.创建全局表格 `redis` ， 这个表格包含了对 Redis 进行操作的函数， 比如用于在 Lua 脚本中执行 Redis 命令的 `redis.call` 函数。
* 4.使用 Redis 自制的随机函数来替换 Lua 原有的带有副作用的随机函数， 从而避免在脚本中引入副作用。
* 5.创建排序辅助函数， Lua 环境使用这个辅佐函数来对一部分 Redis 命令的结果进行排序， 从而消除这些命令的不确定性。
* 6.创建 `redis.pcall` 函数的错误报告辅助函数， 这个函数可以提供更详细的出错信息。
* 7.对 Lua 环境里面的全局环境进行保护， 防止用户在执行 Lua 脚本的过程中， 将额外的全局变量添加到了 Lua 环境里面。
* 8.将完成修改的 Lua 环境保存到服务器状态的 `lua` 属性里面， 等待执行服务器传来的 Lua 脚本。

### 1.替换函数

**随机数**

为了保证相同的脚本在不同机器上产生相同的结果，Redis要求所有传入服务器的脚本已经Lua环境中的函数都必须是无副作用的纯函数。

但是之前Lua环境中用于生成随机数的函数`math.random`和`math.randomseed`都是有副作用的，所以使用Redis自制的函数给替换掉了,达到可以下要求：

* 1.对于相同的seed,math.random函数总产生相同的随机数
* 2.Lua环境中默认使用math.randomseed(0)来seed



**辅助排序函数**

集合是无序的,所以内容相同的集合可能两次输出内容也会不一致。

比如SMEMBERS命令,可能每次打印出来的结果都不一样。

为了解决这个问题Redis增加了一个排序辅助函数来消除这些不确定性。



### 2. 全局保护

为了防止出现意外的错误，Redis不允许传入的脚本修改全局变量。

## 3. 协调组件

Redis为执行Lua脚本创建了一个单独的伪客户端。这个伪客户端只负责执行Lua脚本。

## 3. 执行过程

Redis中Lua脚本执行过程如下：

* 1.根据客户端发来的Lua脚本,在Lua环境中定义一个Lua函数
* 2.将客户端给定的脚本保存到`lua_scripts`字典中，以此来执行给定的额Lua脚本
* 3.执行刚刚定义的Lua函数。



### 1. 定义Lua函数

其中函数名由f_前缀加上脚本的SHA1校验和组成，函数体则是传入的Lua脚本。

比如对于命令`EVAL "return 'hello world'" 0`

服务器定义的函数为

```lua
function f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91()
	return 'hello world'
end
```

其中`return 'hello world'`的SHA1校验值和为`5332031c6b470dc5a0dd9b4bf2030dea6d65de91`

将脚本转成函数保存的好处：

* 1.执行过程简单 只需要调用对应的函数即可
* 2.通过函数的局部性让Lua环境保持清洁，减少了垃圾回收的工作量
* 3.只有脚本对应的函数在Lua环境中定义过一次，后续只要知道SHA1校验和就可以直接调用了，不需要知道脚本具体内容，这就是`EVALSHA`的工作原理

### 2. 保存到lua_scripts字典

`EVAL`命令要做的第二件事就是讲客户端传入的脚本保存到服务器的`lua_scripts`字典里。

比如对于命令`EVAL "return 'hello world'" 0`

服务器会在`lua_scripts`字典中新添加一个键值对，key为Lua脚本的SHA1校验和(5332031c6b470dc5a0dd9b4bf2030dea6d65de91)，value为脚本本身(return 'hello world')。



### 3. 执行脚本函数

服务器还需要进行一些设置钩子，传入参数之类的准备动作，才能正式开启执行脚本。

* 1.将EVAL命令传入的键名和脚本参数分别保存到KEYS数组和ARGV数组，然后将这两个数组作为全局变量传入Lua环境
* 2.为Lua环境装载超时处理钩子，可以在脚本出现运行超时情况下让客户端通过`SCRIPT KILL`命令停止脚本或者`SHUDOWN` 命令直接关闭服务器
* 3.执行脚本函数
* 4.移除超时钩子
* 5.将结果保存到客户端状态的缓冲区，等待服务器将结果返回给客户的。
* 6.对Lua环境执行垃圾回收操作。

## 4. EVALSHA

每个被EVAL命令成功执行的脚本在Lua环境都有一个与之对应的lua函数。函数名为f_前缀加脚本的SHA1校验和组成。例如`f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91`



所以只需要知道脚本的SHA1校验和就可以拼接出脚本函数名，在不知道脚本具体内容的情况下直接调用脚本。

```c
// 伪代码如下
def EVALSHA(sha1)
    // 拼接出函数名
    func_name="f_"+sha1
    if function_exists_in_lua_env(func_name):
		// 存在就执行
		execute_lua_function(func_name)
    else
        // 不存在则抛出错误
        send_script_error("SCRIPT NOT FOUND")
```



## 5. 脚本管理命令

### 1. SCRIPT FLUSH

将会释放并重建`lua_scripts`字典，关闭现有的lua环境重新创建一个新的。

### 2. SCRIPT EXISTS

根据输入脚本的SHA1校验和是否存在于`lua_scripts`字典中

### 3. SCRIPT LOAD

`SCRIPT LOAD`命令所做的事情个EVAL命令执行脚本时所做的前两步完全一样：

* 1.创建对应的函数
* 2.保存到lua_scripts字典中

完成这个命令后客户端就可以使用EVALSHA命令在执行脚本了

### 4. SCRIPT KILL

 如果服务器设置了`lua-time-limit`选项，那么脚本执行期间超时钩子会不断检查脚本运行时长，如果超过了服务器设置值，钩子会检查是否有`SCRIPT KILL`或者`SHUTDOWN`命令到达服务器。

如果脚本未写入数据那么客户端可以通过`SCRIPT KILL`命令来指示服务器停止这个脚本，并向执行该脚本的客户端发送一个错误回复。

如果脚本已经执行过写入操作,那么客户端只能使用`SHUTDOWN nosave`命令来停止服务器，从而防止不合法的数据被写入数据库中。



## 6. 小结

- Redis 服务器在启动时， 会对内嵌的 Lua 环境执行一系列修改操作， 从而确保内嵌的 Lua 环境可以满足 Redis 在功能性、安全性等方面的需要。
- Redis 服务器专门使用一个伪客户端来执行 Lua 脚本中包含的 Redis 命令。
- Redis 使用脚本字典来保存所有被 EVAL 命令执行过， 或者被 SCRIPT_LOAD 命令载入过的 Lua 脚本， 这些脚本可以用于实现SCRIPT_EXISTS 命令， 以及实现脚本复制功能。
- EVAL 命令为客户端输入的脚本在 Lua 环境中定义一个函数， 并通过调用这个函数来执行脚本。
- EVALSHA 命令通过直接调用 Lua 环境中已定义的函数来执行脚本。
- SCRIPT_FLUSH 命令会清空服务器 `lua_scripts` 字典中保存的脚本， 并重置 Lua 环境。
- SCRIPT_EXISTS 命令接受一个或多个 SHA1 校验和为参数， 并通过检查 `lua_scripts` 字典来确认校验和对应的脚本是否存在。
- SCRIPT_LOAD 命令接受一个 Lua 脚本为参数， 为该脚本在 Lua 环境中创建函数， 并将脚本保存到 `lua_scripts` 字典中。
- 服务器在执行脚本之前， 会为 Lua 环境设置一个超时处理钩子， 当脚本出现超时运行情况时， 客户端可以通过向服务器发送SCRIPT_KILL 命令来让钩子停止正在执行的脚本， 或者发送 SHUTDOWN nosave 命令来让钩子关闭整个服务器。
- 主服务器复制 EVAL 、 SCRIPT_FLUSH 、 SCRIPT_LOAD 三个命令的方法和复制普通 Redis 命令一样 —— 只要将相同的命令传播给从服务器就可以了。
- 主服务器在复制 EVALSHA 命令时， 必须确保所有从服务器都已经载入了 EVALSHA 命令指定的 SHA1 校验和所对应的 Lua 脚本， 如果不能确保这一点的话， 主服务器会将 EVALSHA 命令转换成等效的 EVAL 命令， 并通过传播 EVAL 命令来获得相同的脚本执行效果