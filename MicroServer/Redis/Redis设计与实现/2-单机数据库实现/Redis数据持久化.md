# Redis数据持久化

## 1. 概述

由于Redis是内存数据库，所有数据都存储在内存里，如果不想办法持久化到磁盘上,那么服务器一旦退出，所有数据都会消失。

为了解决这个问题Redis提供了RDB和AOF两种持久化功能。



## 2. RDB

思路：备份时生成RDB(快照)文件,恢复时直接加载到内存中。

服务器在加载RDB文件期间,一直处于阻塞状态,知道载入完成。

### 1. 手动触发

手动触发分别对应`save`和`bgsave`命令

**save**

阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间阻塞，线上环境不建议使用。

**bgsave**

Redis进程执行fork操作创建子进程，RDB持久化过程由子 进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短

### 2. 自动触发

1）使用save相关配置，如`save m n`。表示m秒内数据集存在n次修改时自动触发`bgsave`。

2）如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点。

3）执行debug reload命令重新加载Redis时，也会自动触发save操作。

4）默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则 自动执行bgsave。

**bgsave具体步骤**

* 1）执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进 程，如RDB/AOF子进程，如果存在bgsave命令直接返回。

* 2）父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通 过info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗时，单位为微秒

* 3）父进程fork完成后，bgsave命令返回“Background saving started”信息并不再阻塞父进程，可以继续响应其他命令。

* 4）子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后 对原有文件进行原子替换。执行lastsave命令可以获取最后一次生成RDB的 时间，对应info统计的rdb_last_save_time选项。

* 5）进程发送信号给父进程表示完成，父进程更新统计信息，具体见 info Persistence下的rdb_*相关选项。

### 3. 优缺点

**优点**

* 1.RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份， 并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。
* 2.Redis加载RDB恢复数据远远快于AOF的方式。

**缺点**

* 1.RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运 行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。
* RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式 的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。



针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。

## 3. AOF

AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用 是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。

### 1. 开启AOF

开启AOF功能需要设置配置：`appendonly yes`，默认不开启。AOF文件名 通过`appendfilename`配置设置，默认文件名是`appendonly.aof`。

保存路径同 RDB持久化方式一致，通过dir配置指定。

### 2. 具体流程

AOF的工作流程操作：

* 1.命令追加(append)
* 2.文件写入、文件同步(sync)
* 3.重启加载



**1.命令写入(append)**

所有的写入命令会追加到`aof_buf(缓冲区)`中

> AOF为什么把命令追加到aof_buf中？Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡

**2.文件写入/文件同步(sync)**

先将命令写入缓冲区,然后再跟据缓冲区同步硬盘的策略将命令追加到硬盘的aof文件。

具体可以配置`appendfsync`参数进行调整。

**3.重启加载**

服务器重启时如果开启了AOF持久化则会优先加载AOF文件。因为AOF持久化的数据相比RDB更加完整。

加载其实是将AOF文件中的命令都执行一遍,这样数据就和之前的一致了，最多丢失1秒钟的数据(AOF持久化一般配置为每秒写入一次)。

### 3. 文件重写(rewrite)

随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。

**虽然是叫重写,但实际和AOF文件没关系，是直接读取数据库状态然后写入命令。**

* 1.进程内已经超时的数据不再写入文件。
* 2.无效命令不在写入
* 3.多条命令合并为一条

AOF重写降低了文件占用空间，除此之外，另一个目的是：更小的AOF 文件可以更快地被Redis加载。

*触发方式*

执行`BGREWRITEAOF`命令手动触发

满足以下条件则服务器被动触发

* 1.没有BGSAVE命令（RDB持久化）/AOF持久化在执行；
* 2.没有BGREWRITEAOF在进行；
* 3.当前AOF文件大小要大于`server.aof_rewrite_min_size`(默认为1MB),或者在`redis.conf`配置了`auto-aof-rewrite-min-size`大小
* 4.当前AOF文件大小和最后一次重写后的大小之间的比率等于或者大于指定的增长百分比（在配置文件设置了`auto-aof-rewrite-percentage`参数，不设置默认为100%）

大概就是大于1M且相对上次重写后的文件增长了指定百分比就会且当前没有其他`BGSAVE`和`BGREWRITEAOF`在执行就会触发。

> `BGSAVE`和`BGREWRITEAOF`命令都会大量写入磁盘，为了性能考虑，Redis服务器暂时不允许两个命令同时执行，一个执行时另一个会等待。

## 4. 小结

**RDB快照机制全量备份，适合冷备**

优点:fork子进程进行持久化，对性能影响小，且数据恢复是比AOF快。

缺点：快照机制，默认5分钟持久化一次，可能会丢失中间的所有数据，生成快照是文件过大时客户端还是会出现暂停现象。

**AOF增量备份，适合热备**

优点：1秒1次去通过后台线程执行fsync操作，最多丢失1秒的数据

缺点：相同数据AOF文件比RDB要大。