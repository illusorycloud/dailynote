# Redis复制功能

## 1. 旧版本(2.8之前)复制实现

Redis 的复制功能分为同步（sync）和命令传播（command propagate）两个操作：

- 其中， 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。
- 而命令传播操作则用于在主服务器的数据库状态被修改， 导致主从服务器的数据库状态出现不一致时， 让主从服务器的数据库重新回到一致状态。



### 1. 同步

当客户端向从服务器发送 SLAVEOF 命令， 要求从服务器复制主服务器时， 从服务器首先需要执行同步操作， 也即是， 将从服务器的数据库状态更新至主服务器当前所处的数据库状态。

从服务器对主服务器的同步操作需要通过向主服务器发送 SYNC 命令来完成， 以下是 SYNC 命令的执行步骤：

* 1.从服务器向主服务器发送 SYNC 命令。
* 2.收到 SYNC 命令的主服务器执行 BGSAVE 命令， 在后台生成一个 RDB 文件， 并使用一个缓冲区记录从现在开始执行的所有写命令。
* 3.当主服务器的 BGSAVE 命令执行完毕时， 主服务器会将 BGSAVE 命令生成的 RDB 文件发送给从服务器， 从服务器接收并载入这个 RDB 文件， 将自己的数据库状态更新至主服务器执行 BGSAVE 命令时的数据库状态。
* 4.主服务器将记录在缓冲区里面的所有写命令发送给从服务器， 从服务器执行这些写命令， 将自己的数据库状态更新至主服务器数据库当前所处的状态。

### 2. 命令传播

在同步操作执行完毕之后， 主从服务器两者的数据库将达到一致状态， 但这种一致并不是一成不变的 —— 每当主服务器执行客户端发送的写命令时， 主服务器的数据库就有可能会被修改， 并导致主从服务器状态不再一致。

为了让主从服务器再次回到一致状态， 主服务器需要对从服务器执行命令传播操作：**主服务器会将自己执行的写命令(即造成主从服务器不一致的那条写命令)发送给从服务器执行**， 当从服务器执行了相同的写命令之后， 主从服务器将再次回到一致状态。

### 3. 缺陷

在Redis中复制分为两种情况

* 1.初次复制：从服务器没有复制过任何主服务器，或主服务器换了。

* 2.断线后重复制：处于命令传播阶段的从服务器，断线后重连上来又会进行一次SYNC，效率很低。

  SYNC很耗费资源的命令,假设执行了1W个写命令，可能到第9999个时从服务器才掉线，那么重连后只需要把最后一个复制上就行了，没必要从第一个开始完整的复制。

## 2. 新版本

为了解决旧版复制功能在处理断线重复制情况下的低效问题，Redis从2.8版本开始使用PSYNC命令代替SYNC来执行复制时的同步操作。

PSYNC具体完整重同步和部分重同步两种模式。

* 完整重同步:和SYNC基本一致。
* 部分重同步:用于断线后重复制，如果条件允许主服务器可以将从服务器断线期间执行的写命令发送给从服务器，从服务器只需要执行这些命令即可更新至主服务器当前所处的状态，大大提升复制效率。



### 1. PSYNC实现逻辑

部分重同步功能由一下三个部分构成：

* 1.主从服务器各种的复制偏移量
* 2.主服务器的复制积压缓冲区
* 3.服务器的运行ID(run ID)



**复制偏移量**

主服务器向从服务器`传播`N个字节数据时,就将自己的复制偏移量加上N。

从服务器每次`接收`到主服务器传播来的N字节数据时也把自己的复制偏移量加上N。

**复制积压缓冲区**

复制积压缓冲区是由主服务器维护的一个固定长度先进先出队列，默认大小为1MB。

每次传播数据给从服务器时也会存到复制积压缓冲区,同时记录了`命令`和对应的`复制偏移量`

从服务器掉线重连后会通过PSYNC命令把自己的复制偏移量发给主服务器。

主服务器根据偏移量进行判断，如果从服务器重连后缺的命令在复制积压缓冲区里面有，那么只需要执行部分重同步

如果掉线太久，数据被挤掉了那就执行完整重同步

**服务器的运行ID**

每个Redis服务器，不论主从都会有自己的运行ID,在服务器启动时自动生成,由40个随机16进制字符串组成。

从服务器进行初次复制时，主服务器会将自己的运行ID传给从服务器，有从服务器保存起来，

从服务器掉线重连后根据运行ID来判断现在连的是不是之前连的那个主服务器。

如果掉线后连上的都不是同一个主服务器了，那肯定要执行完整重同步。



### 2. 具体流程

PSYNC命令调用有两种：

如果是初次复制则发送`PSYNC ? -1`主动请求主服务器进行完整重同步。

否则发送`PSYNC <runid> <offset>`命令

其中runid为上一个主服务器的runid，offset则是当前从服务器的复制偏移量，主服务器会根据情况作出3种回复。

* 1.`+FULLRESYNC <runid> <offset>`

表示需要执行完整重复制，runid为这个主服务器的runid,offset也是主服务器的复制偏移量，从服务器需要将这个值作为自己的复制偏移量。

* 2.`+CONTINUE`

则只执行部分重同步，从服务器只需要等着主服务器把自己缺少的部分命令发过来即可。

* 3.`-ERR`

表示主服务器版本过低,识别不了PSYNC命令，从服务器后续会发生SYNC命令进行完整重同步

### 3. 复制操作

**1.主服务器地址和端口**

在执行`SLAVEOF host port `命令的时候，从服务器会保存主服务的地址的端口

```c
struct redisServer {
    // 主服务器地址
    char *masterhost
    // 主服务器端口
    int masterport
}
```



**2.建立套接字连接**

通过前面的地址和端口建立套接字连接，到此从服务器可以看成是主服务器的一个客户端了。



**3.发送PING命令**

在建立连接后从服务器可以看成是主服务器的一个客户端，然后从服务器发送PING命令，检查双方能否正常通信，如果正常的话主服务器会返回PONG



**4.身份验证**

如果从服务器设置了`masterauth`则会进行身份验证，没设置则不进行验证。

但是如果主服务器设置了`reuqirepass` 那么必须验证 否则主服务器会返回一个NOAUTH错误。

简单说就是从服务器的`masterauth`就是填的主服务器的密码。

只有设置成主服务器的`requirepass`一致才能正常复制。

**5.发送端口信息**

通过身份验证后从服务器会向主服务器发送自身监听的端口

命令为`REPLCONF listening-port <port-number>`

主服务会存到client信息中

```c
typedef struct redisClient {
    // ...
    // 从服务器的监听端口
    int slave_listen_port;
     // ...
}redisClient;
```

**6. 同步**

到这一步从服务器向主服务器发送PSYNC命令,执行同步操作，更新到主服务器所处状态。

**7.命令传播**

完成同步后，主从服务器就进入命令传播阶段，主服务器将执行的写操作传给从服务器执行就能一直保证状态一致了。

## 3. 心跳检测

在命令传播阶段,从服务器默认会以每秒一次的频率向主服务器发送命令

`REPLCONF ACK <replication_offset>`

其中`replication_offset`是从服务器的复制偏移量

该命令主要有3个作用

* 1.检测主从服务器网络连接状态
* 2.辅助实现min_slaves选项

`min_slaves`用于防止主服务器在不安全的情况下执行命令。

假设设置如下

```sh
min_slaves_to_write=3
min_slaves_max_log=10
```

那么在从服务器少于3个或者3个或以上从服务器的延迟值都大于10秒，此时主服务器将拒绝执行写请求。

* 3.检测命令丢失

如果主服务器发给从服务器的命令因为网络问题丢了，那么从服务器发送的`replication_offset`就会对不上，这样可以检测出是否有命令丢失

## 4. 小结

- Redis 2.8 以前的复制功能不能高效地处理断线后重复制情况， 但 Redis 2.8 新添加的部分重同步功能可以解决这个问题。
- 部分重同步通过复制偏移量、复制积压缓冲区、服务器运行 ID 三个部分来实现。
- 在复制操作刚开始的时候， 从服务器会成为主服务器的客户端， 并通过向主服务器发送命令请求来执行复制步骤， 而在复制操作的后期， 主从服务器会互相成为对方的客户端。
- 主服务器通过向从服务器传播命令来更新从服务器的状态， 保持主从服务器一致， 而从服务器则通过向主服务器发送命令来进行心跳检测， 以及命令丢失检测。