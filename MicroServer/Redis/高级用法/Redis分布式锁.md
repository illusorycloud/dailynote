# Redis分布式锁

## 1. 概述

关于分布式锁的实现有很多，比较常见的有`etcd`、`zookeeper`、`redis`等

这里讲一下redis实现的分布式锁。

## 2. 单节点

### 方案一

使用Redis实现分布式锁最简单的方案是在获取锁之前先查询一下以该锁为key对应的value存不存在。

如果存在，则说明该锁被其他客户端获取了。

否则的话就尝试获取锁，获取锁的方法很简单，只要以该锁为key，设置一个随机的值就行了。

```go
// 伪代码如下
func main(){
	if getLock() {
		defer releaseKey()
		doSomething()
	}
}

func getLock() bool {
	if existKey(FirstLock) {
		return false
	} else {
		setKey(FirstLock)
		return true
	}
}
func releaseKey(){
	deleteKey(FirstLock)
}
```

### 方案二

方案一咋一看是没有什么问题的。但是真使用起来会有两个最大的问题。

* 1.如果获取锁后程序崩溃则无法释放锁 其他线程永远获取不了
* 2.`existKey`和`setKey`不是原子操作 可能出现多个程序同时获取锁的情况



解决第一个问题可以给锁添加过期时间,到期后自动释放锁。

解决第二个问题就可以使用`setnx`命令 只有当key不存在时才会设置成功。

### 方案三

方案二通过使用`setnx`命令和设置过期时间的方式解决了方案一中的两个问题。

然而添加过期时间后可能有出现新的问题。



假设A获取到锁设置了过期时间(假设为3秒),结果业务逻辑执行了4秒，但是3秒的时候锁已经被释放了，可能现在都被其他客户端获取了，然后A现在业务逻辑执行完之后去释放锁，可能会把其他客户端刚获取到的锁给释放掉。



为了解决这个问题可以在设置锁的时候给value设置一个随机值，释放锁的时候只有当前锁对应的value是这个随机值的时候才释放。

大概这样

```go
func releaseKey() {
	if getKey(FirstLock) == randomValue {
		deleteKey(FirstLock)
	}
}
```

### 方案四

方案三还是有问题 因为释放锁不是原子操作。

在`getKey`和`deleteKey`之前可能锁到期了，其他客户端也获取到锁了，这边还是会去释放锁。



为了实现原子性可以使用lua脚本来执行释放锁的操作。

```lua
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

其中KEYS[1]就是锁的key`keyname`,ARGV[1]即`randomValue`



到这里方案就比较完善了，不过这仅仅是单机下的方案。

实际上还是有问题的。

宕机问题

假如Redis节点宕机了，那么所有客户端就都无法获得锁了，服务变得不可用。为了提高可用性，我们可以给这个Redis节点挂一个Slave，当Master节点不可用的时候，系统自动切到Slave上（failover）。但由于Redis的主从复制（replication）是异步的，这可能导致在failover过程中丧失锁的安全性。考虑下面的执行序列：

1. 客户端1从Master获取了锁。
2. Master宕机了，存储锁的key还没有来得及同步到Slave上。
3. Slave升级为Master。
4. 客户端2从新的Master获取到了对应同一个资源的锁。

于是，客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破。

## 3. 集群(Redlock)

由于前面介绍的基于单Redis节点的分布式锁在failover的时候会产生解决不了的安全性问题，因此antirez提出了新的分布式锁的算法Redlock，它基于N个完全独立的Redis节点（通常情况下N可以设置成5）。

运行Redlock算法的客户端依次执行下面各个步骤，来完成获取锁的操作：

1. 获取当前时间（毫秒数）。
2. 按顺序依次向N个Redis节点执行获取锁的操作。这个获取操作跟前面基于单Redis节点的获取锁的过程相同，包含随机字符串`my_random_value`，也包含过期时间(比如`PX 30000`，即锁的有效时间)。为了保证在某个Redis节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个Redis节点获取锁失败以后，应该立即尝试下一个Redis节点。这里的失败，应该包含任何类型的失败，比如该Redis节点不可用，或者该Redis节点上的锁已经被其它客户端持有（注：Redlock原文中这里只提到了Redis节点不可用的情况，但也应该包含其它的失败情况）。
3. 计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数Redis节点（>= N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。
4. 如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间。
5. 如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起释放锁的操作（即前面介绍的Redis Lua脚本）。



> redis分布式锁是否安全？
>
> https://www.cnblogs.com/williamjie/p/11151742.html
>
> https://www.cnblogs.com/williamjie/p/11151753.html

按照锁的两种用途，如果仅是为了效率(efficiency)，那么你可以自己选择你喜欢的一种分布式锁的实现。当然，你需要清楚地知道它在安全性上有哪些不足，以及它会带来什么后果。而如果你是为了正确性(correctness)，那么请慎之又慎。