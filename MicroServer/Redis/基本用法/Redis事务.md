# Redis事务

## 1. 概述

Redis通过`MULTI `、`EXEC`、`WATCH`等命令来实现事务(transation)。

事务提供了一种将多个请求打包，然后一次性、按顺序执行的机制,并且在事务执行过程中，服务器不会中断事务去执行其他客户端的命令，知道事务中所有命令都执行完毕才会去处理其他客户端的请求。

## 2. 事务流程

执行流程如下

个事务从开始到执行会经历以下三个阶段：

- 开始事务。
- 命令入队。
- 执行事务。

```c
// 开始事务
127.0.0.1:6379> multi
OK
// 命令入队    
127.0.0.1:6379> set a test1
QUEUED
127.0.0.1:6379> set b test2
QUEUED
// 执行事务    
127.0.0.1:6379> exec
1) OK
2) OK
// 查一下看下入成功没    
127.0.0.1:6379> get a
"test1"
127.0.0.1:6379> get b
"test2"
```

## 3. Watch

到 redis 事务，就不得不提 watch 命令了。

该命令是一个乐观锁，只能在客户端进入事务状态之前执行。

**作用是 exec 命令执行之前，监视任何数量个键，并在 exec 命令执行时，检查被监视的键是否至少有一个已经被修改过。若是则拒绝执行事务，否则执行**。

当 exec 执行完成后，这次事务也就结束了。

我们依旧来看一个简单的栗子：

```c
127.0.0.1:6379> SET msg test  //设置 msg 的值
OK
127.0.0.1:6379> WATCH msg //监视 msg
OK
127.0.0.1:6379> SET msg test2 //修改 msg 的值（或其他客户端在该客户端执行 exec 命令之前修改该值）
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET msg test3
QUEUED
127.0.0.1:6379> GET msg
QUEUED
127.0.0.1:6379> EXEC 
(nil)   //执行失败
```

## 4. API

```sh
#标记一个事务块的开始。
MULTI
#执行所有事务块内的命令。
EXEC
#取消事务，放弃执行事务块内的所有命令。
DISCARD
#监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。
WATCH key [key ...]
#取消 WATCH 命令对所有 key 的监视。
UNWATCH
```

