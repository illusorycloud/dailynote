# 同步异步阻塞非阻塞

## 1. 概述

### 1. 简单理解

- **同步：** 同步就是调用者发起一个调用后，被调用者未处理完请求之前，调用不返回。
- **异步：** 异步就是调用者发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。

**同步和异步的区别在于同步需要调用者需要等待处理结果，异步则调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果**。

- **阻塞：** 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。
- **非阻塞：** 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。

**阻塞与非阻塞表示线程状态，最大区别在于阻塞会挂起当前线程，非阻塞则不会**。



### 2. 差异

* `同步异步`与`被调用者`有关。在处理完成后会通过回调通知调用者一般就是异步，不然就需要调用者自己查询处理结果。
* `阻塞非阻塞`与`调用者`有关。调用者在发出请求后返回结果前这段时间能做其他事就是非阻塞，否则就是阻塞。



### 3. 原理

实际上同步与异步是针对**应用程序与内核的交互**而言的，针对的是应用程序，关注的是**程序中间的协作关系**；

* **同步**：执行一个操作之后，进程触发I/O操作并等待(也就是我们说的阻塞)或者轮询的去查看I/O操作(也就是我们说的非阻塞)是否完成，等待结果，然后才继续执行后续的操作。

* **异步**：执行一个操作后，可以去执行其他的操作，然后等待通知再回来执行刚才没执行完的操作。

阻塞与非阻塞更关注的是**单个进程的执行状态**。

* **阻塞**：进程给CPU传达一个任务之后，一直等待CPU处理完成，然后才执行后面的操作。

* **非阻塞**：进程给CPU传达任务后，继续处理后续的操作，过段时间再来询问之前的操作是否完成。这样的过程其实也叫轮询。



**同步有阻塞和非阻塞之分，异步没有，它一定是非阻塞的。**

> 阻塞、非阻塞、多路IO复用，都是同步I/O，异步必定是非阻塞的，不存在异步阻塞和异步非阻塞的说法。

**真正的异步I/O需要CPU的深度参与**，换句话说，只有用户线程在操作I/O的时候根本不去考虑I/O的执行，全部都交给CPU去完成，而自己只等待一个完成信号的时候，才是真正的异步I/O。

>所以，拉一个子线程去轮询、去死循环，或者使用select、poll、epool，都不是异步。



## 2. select/pool/epoll

### 1. select

时间复杂度O(n)

select 仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部）。我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以**select具有O(n)的无差别轮询复杂度**，同时处理的流越多，无差别轮询时间就越长。

**select的几大缺点：**

**（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大**

**（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大**

**（3）select支持的文件描述符数量太小了，默认是1024**

### 2. poll

时间复杂度O(n)

poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， **但是它没有最大连接数的限制**，原因是它是基于链表来存储的。

### 3. epoll

时间复杂度O(1)

**epoll可以理解为event poll**，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是**事件驱动（每个事件关联上fd）**的，此时我们对这些流的操作都是有意义的。**（复杂度降低到了O(1)）**

select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。**但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的**，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。  

epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现.



### 4. 小结

* 1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。
* 2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。



