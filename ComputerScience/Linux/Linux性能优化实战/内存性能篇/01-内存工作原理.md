# 内存工作原理

## 1. 概述

我们通常所说的内存容量，其实指的是物理内存。物理内存也称为主存，大多数计算机用的主存都是`动态随机访问内存（DRAM）`。

**只有内核才可以直接访问物理内存**。

为了让进程也能访问内存，于是出现了**内存映射**。



Linux 内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。

> 这样，进程就可以很方便地访问内存，更确切地说是访问虚拟内存。

虚拟内存空间布局如下图所示：

![](assets/linux-memory-structure.png)





## 2. 内存映射

**内存映射，其实就是将虚拟内存地址映射到物理内存地址**。为了完成内存映射，内核为每个进程都维护了一张`页表`，记录虚拟地址与物理地址的映射关系。

![./assets/内存映射.png](./assets/内存映射.png)

页表实际上存储在 CPU 的内存管理单元 MMU 中，这样，正常情况下，处理器就可以直接通过硬件，找出要访问的内存。

而当进程访问的虚拟地址在页表中查不到时，系统会产生一个**缺页异常**，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。



注意：MMU 并不以字节为单位来管理内存，而是规定了一个内存映射的最小单位，也就是页，通常是 4 KB 大小。

页的大小只有 4 KB ，导致的另一个问题就是，整个页表会变得非常大。比方说，仅 32 位系统就需要 100 多万个页表项（4GB/4KB），才可以实现整个地址空间的映射。为了解决页表项过多的问题，Linux 提供了两种机制，也就是**多级页表**和**大页（HugePage）**。

Linux 用的正是四级页表来管理内存页，如下图所示，虚拟地址被分为 5 个部分，前 4 个表项用于选择页，而最后一个索引表示页内偏移。

![](assets/多级页表.png)

大页，就是比普通页更大的内存块，常见的大小有 2MB 和 1GB。大页通常用在使用大量内存的进程上，比如 Oracle、DPDK 等。



## 3. 内存布局

虚拟内存分为上方的内核空间和下方的用户空间，而用户空间内存其实又被分成了多个不同的段。以 32 位系统为例,用户空间内存布局如下所示：

![](assets/memory-structure.png)



* 只读段，包括代码和常量等。
* 数据段，包括全局变量等。
* 堆，包括动态分配的内存，从低地址开始向上增长。
* 文件映射段，包括动态库、共享内存等，从高地址开始向下增长。
* 栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。

在这五个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存。



## 4. 内存分配与回收

### 分配

malloc() 是 C 标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即 brk() 和 mmap()。

对小块内存（小于 128K），C 标准库使用 brk() 来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。

而大块内存（大于 128K），则直接使用内存映射 mmap() 来分配，也就是在文件映射段找一块空闲内存分配出去。

brk() 方式的缓存，可以减少缺页异常的发生，提高内存访问效率。不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片。

而 mmap() 方式分配的内存，会在释放时直接归还系统，所以每次 mmap 都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大。这也是 malloc 只对大块内存使用 mmap  的原因。

### 回收

应用程序需要调用对应的  free() 或 unmap()函数手动回收内存。

在发现内存紧张时，系统就会通过一系列机制来回收内存，比如下面这三种方式：

* 回收缓存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面；
* 回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中；
  * 即swap 交换分区。
* 杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程。
  * 内核的一种保护机制





## 5. 查看内存使用情况

查看整个系统的内存使用情况可以使用 `free` 命令：

```sh
$ free -h
              total        used        free      shared  buff/cache   available
Mem:           7.6G        4.0G        163M         36M        3.4G        3.1G
Swap:            0B          0B          0B
```

数据含义

* 第一列，total 是总内存大小；
* 第二列，used 是已使用内存的大小，包含了共享内存；
* 第三列，free 是未使用内存的大小；
* 第四列，shared 是共享内存的大小；
* 第五列，buff/cache 是缓存和缓冲区的大小；
* 最后一列，available 是新进程可用内存的大小。

最后一列 available 不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。

如果你想查看进程的内存使用情况，可以用 top 或者 ps 等工具

```sh
$ top
top - 12:59:59 up 365 days,  3:31,  3 users,  load average: 0.14, 0.13, 0.14
Tasks: 166 total,   1 running, 163 sleeping,   0 stopped,   2 zombie
%Cpu(s): 10.9 us,  1.6 sy,  0.0 ni, 87.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  8008880 total,   178080 free,  4219944 used,  3610856 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  3274816 avail Mem 

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                                                                                  
13062 mosquit+  20   0 1328244 203552   6548 S  25.0  2.5  13:29.45 node                                                                                                                                                                     
14667 root      20   0  986112 120792   9020 S   6.2  1.5 457:35.57 node /usr/local                                                                                                                                                          
26764 mosquit+  20   0 4352356   1.1g 171136 S   6.2 14.2 365:20.10 java                                                                                                                                                                     
    1 root      20   0   76836   3432   1516 S   0.0  0.0  79:37.20 systemd    
```

前几行是系统整体内存使用情况，和 free 差不多，后面是每个进程的内存使用情况，具体含义如下：

* VIRT 是进程虚拟内存的大小，只要是**进程申请过的内存**，即便还没有真正分配物理内存，也会计算在内。
* RES 是常驻内存的大小，也就是**进程实际使用的物理内存大小**，但不包括 Swap 和共享内存。
* SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。
* %MEM 是进程使用物理内存占系统总内存的百分比。





## 6. 资料

`https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/`