# Linux 中断

## 1. 概述

**中断其实是一种异步的事件处理机制，可以提高系统的并发处理能力**。

由于中断处理程序会打断其他进程的运行，所以，为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行。

特别是，中断处理程序在响应中断时，还会临时关闭中断。这就会导致上一次中断处理完成之前，其他中断都不能响应，也就是说中断有可能会丢失。

> 即中断处理过程中不会接收新的中断请求。



## 2. 硬中断、软中断

事实上，为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：

* 上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。
* 下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。





网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它。你可以自己先想一下，这种情况下的上半部和下半部分别负责什么工作呢？

对上半部来说，既然是快速处理，其实就是要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了），最后再发送一个软中断信号，通知下半部做进一步的处理。

而下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序。

所以，这两个阶段你也可以这样理解：

* 上半部直接处理硬件请求，也就是我们常说的硬中断，特点是快速执行；
* 而下半部则是由内核触发，也就是我们常说的软中断，特点是延迟执行。

> 实际上，上半部会打断 CPU 正在执行的任务，然后立即执行中断处理程序。而下半部以内核线程的方式执行，并且每个 CPU 都对应一个软中断内核线程，名字为 “ksoftirqd/CPU 编号”，比如说， 0 号 CPU 对应的软中断内核线程的名字就是 ksoftirqd/0。



## 3. 查看软中断和内核线程

内核空间和用户空间可以使用 proc 文件系统进行通信，中断相关信息也在这里面：

* /proc/softirqs 提供了软中断的运行情况；
* /proc/interrupts 提供了硬中断的运行情况。



```sh
$ cat /proc/softirqs
                    CPU0       CPU1       CPU2       CPU3       
          HI:          1          0          0          0
       TIMER: 3976189477 2561531266 4011311173 2710417947
      NET_TX:       2876       1534       2232       1536
      NET_RX: 1312865293  911184931 1239283194  853610802
       BLOCK:          0          0          0          0
BLOCK_IOPOLL:          0          0          0          0
     TASKLET:        756         30        598         29
       SCHED: 1771374511 1070264496 1699953885 1180994289
     HRTIMER:          0          0          0          0
         RCU: 2292971159 1547917736 2286000832 1632404430

```

在查看 /proc/softirqs 文件内容时，你要特别注意以下这两点。

* 第一，要注意软中断的类型，也就是这个界面中第一列的内容。从第一列你可以看到，软中断包括了 10 个类别，分别对应不同的工作类型。
  * 比如 NET_RX 表示网络接收中断，而 NET_TX 表示网络发送中断。
* 第二，要注意同一种软中断在不同 CPU 上的分布情况，也就是同一行的内容。正常情况下，同一种中断在不同 CPU 上的累积次数应该差不多。
  * 比如这个界面中，NET_RX 在 CPU0 和 CPU1 上的中断次数基本是同一个数量级，相差不大。