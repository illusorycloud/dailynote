# 方法

## 概述

在某些情况下，我们要需要声明(定义)方法。比如Person结构体:除了有一些字段外(年龄、姓名..)。Person结构体还有一些行为比如:可以说话、跑步...学习，还可以做算术题。这时就要用方法才能完成。
Golang中的方法是**作用在指定的数据类型上的**(即：和指定的数据类型绑定}，因此**自定义类型，都可以有方法**，而不仅仅是struct。

```go
//结构体A
type A struct{

}
//方法test 只有A类型可以调用
func (a A)test(){
    
}
var a A
a.test()

```

## 例子

```go
package main

import "fmt"

func main() {
	p1 := Personm{"illusory", 11}
	p1.run() //调用方法
}

type Personm struct {
	Name string
	Age  int
}

//给Personm绑定一个方法
func (person Personm) run() {
	fmt.Printf("%s running....", person.Name)
}

```

说明：

* 1.run 方法和 Personm 结构体绑定
* 2.run 方法只能通过 Personm 类型的变量来调用，不能使用其他类型或者直接调用
* 3.func (`person` Personm) run() {} 这里的 person 表示哪个 Person 变量调用，这个 person 就是它的副本，和函数传参非常相似
* 4.person 这个名字可以随意指定 不是固定的

## 方法调用和传参原理

方法的调用和传参机制与函数基本一样，不一样的地方是方法调用时，**会将调用方法的变量，当做实参也传递给方法**。

为了提高效率，通常和方法绑定的是结构体的指针类型

```go
package main

import "fmt"

func main() {
	p1 := Personm{"illusory", 11}
    (&p1).run() //正常调用
	p1.run() //编译器底层优化 直接这样调用也是可以的 会自动转化为上面的调用方式
}

type Personm struct {
	Name string
	Age  int
}

//给Personm绑定一个方法
func (person *Personm) run() {
	fmt.Printf("%s running....", person.Name)
}

```

## 方法注意事项与细节

* 1.结构体类型是值类型，在方法调用中，遵守值类型的传递机制，是值拷贝传递方式
* 2.如程序员希望在方法中，修改结构体变量的值，可以通过结构体指针的方式来处理
* 3.Golang中的方法**作用在指定的数据类型上**的(即：**和指定的数据类型绑定**)，因此**自定义类型，都可以有方法**，而不仅仅是struct,比如int,float32等都可中以有方法
* 4.方法的访问范围控制的规则，和函数一样。方法名首字母小写，只能在本包访问，方法首字母大写，可以在本包和其它包访问。
* 5.如果一个变量实现了String()这个方法，那么fmt.Println默认会调用这个变量的String()进行输出,类似Java中的toString()

## 方法与函数差别

* 1.调用方式不一样

函数调用：函数名(实参列表)

方法调用：变量.方法名(实参列表)

* 对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然
* 3.对于方法(如struct 的方法)，接收者为值类型时，可以直接用指针类型的变量调用方法，反之亦然

**编译器底层会自动转化，最终还是以绑定类型为准** 

```go
package main

import "fmt"

func main() {
	p1 := Personm{"illusory", 11}
    (&p1).run() //正常调用
	p1.run() //编译器底层优化 直接这样调用也是可以的 会自动转化为上面的调用方式 看起来是传递值但是最后还是传递的指针 内部对Name的修改依旧会影响到外部的值
}

type Personm struct {
	Name string
	Age  int
}

//给Personm绑定一个方法 传递的是指针
func (person *Personm) run() {
    person.Name="tom" //修改Name
	fmt.Printf("%s running....", person.Name)
}

```

**总结：**不管调用形式如何，真正**决定是值拷贝还是地址拷贝**的是**该方法和哪个类型绑定的**

如果是和值类型绑定：(person Person) 则是值拷贝

如果是和引用类型绑定：(person *Person) 则是地址拷贝