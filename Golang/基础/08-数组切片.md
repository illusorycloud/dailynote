# 数据类型

## 1. 数组

语法格式

go语言声明数组需要指定**元素类型**及**元素个数**

**数组是值类型**，传递参数时会复制一份。



```go
//一维数组
var 变量名 [数组长度]数据类型
```

数组长度必须大于0，数组一旦定义，大小不能更改。

未初始化的数组不是nil，没有空数组（与slice的区别）//未初始化有默认值 根据类型不同而不同

* **初始化数组**

```go
var nums =[5]int{1,2,3,4,5}
//忽略[]中的数字 由编译器根据后面的元素个数来计算数组长度
var nums =[...]int{1,2,3,4,5} //这里...会自动替换为5
```

一般不会直接使用数组，会选择使用**切片slice**。

## 2. 切片

### 2.1 概述

**go语言切片是对数组的抽象，切片没有自己的数据，它只是底层数组的一个引用，对切片的所有修改都将反应在底层数组中**。

**数组是值类型，切片是个引用类型**。

go中数组长度不可变，在特定场合中不够灵活，于是提供了一种灵活、功能强悍的内置类型切片。

* 与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容置增大 

* 切片本身没有任何数据，它们只是对现有数组的引用。

* 切片与数组相比，不需要设定长度，在1 中不用设定值，相对来说比较自由 

* **从概念上面来说slice像一个结构体**，这个结构体包含了三个元素：

  * **指针**，指向数组中slice指定的开始位置 
  * **长度**，即slice的长度
  * **最大长度/容量**，也就是slice开始位置到数组的最后位置的长度

  ```go
  type slice struct{
      ptr *[2]int //    ptr *[2]int //d
      len int
      cap int
  }
  ```

  

### 2.2 切片的声明

#### 1. 直接声明切片

声明一个未指定长度的数组来定义切片 

* var identifier [I type 
* 切片不需要说明长度。
* 该声明方式，且未初始化的切片为空切片。该切片默认为nil,长度为0。

```go
//声明切片1 未初始化时为nil
var s1 []int
```

#### 2. make方式声明

* 1.通过make方式创建切片可以指定大小和容量
* 2.如果没给切片的各个元素赋值，那么会使用默认值
* 3.通过make方式创建的切片对应的数组由make底层维护，对外不可见，即只能通过slice访问

```go
//声明切片2.1 make方式声明的切片不为nil 有默认值 这里int型默认值为0
var s2 []int = make([]int, 5)
var s3 []int = make([]int, 5, 7)
```

#### 3. 直接赋值

 ```go
var s6 []int=[]int{1,3,4,5,7}  //len=5 cap=5
 ```

这种方式声明的切片len和cap等于元素个数。

### 2.3切片 append 动态扩容

切片底层是指向的一个数组，添加元素时如果超越cap，系统会重新分配更大的底层数组，原来的数组会被垃圾回收。

扩容原理分析：

* 1.切片 append 操作本质是对数组扩容

* 2.go 底层会创建一个新的数组 newArr(按照扩容后的大小)

* 3.将 slice 原来包含的元素拷贝到新的数组 newArr

* 4.slice 重新引用到 newArr

* 5.注意 newArr 是在底层维护的，程序员不可见

slice扩容大小

```go
0 1 2 4 8 16 32 64 128 // 每次扩大为原来的两倍 定义后没有初始化时 len=0 cap=0 slice=nil
```



### 2.4 copy 切片拷贝

```go
//将src拷贝到dst 必须两者都是切片类型才能拷贝
copy(dst,src)
```

```go
var s6 []int = []int{1, 3, 4, 5, 7} 	
s4 := make([]int, 5) //全是默认值 {0,0,0,0,0}

fmt.Println(s4)//拷贝之前 [0 0 0 0 0]
copy(s4,s6) //将s6拷贝到s4
fmt.Println(s4)//拷贝之后 [1 3 4 5 7]
```

**可以将大切片拷贝给小切片**

```go
var s1 []int = []int{1, 3, 4, 5, 7} 	
s2 := make([]int, 1) //全是默认值 [0]
copy(s2,s1) //将s1拷贝到s2 由于s2长度为1 所以最终只会拷贝1个元素 但是不会报错
fmt.Println(s2） //[1]
```

可以取到切面后的值

```go
arr:=[...]int{1,2,3,4,5,6,7,8}
s1:=arr[2:6]  // {3,4,5,6}
s2:=s1[3:5]   //{6,7}

```

**问题 s1只有{3,4,5,6}4个数 为什么s2可以取到{7} s1中并没有这个数**

其实slice是可以扩展的

>  数据结构类似 `{--len--|--cap--}`

slice 包含一个`len 长度` 通过`s1[index]`取值时 只能取到`len`部分的值 
slice 还包含一个 `cap 容量` 在`len之外`还有额外的一部分值 这是`通过s1[index]无法取到的`
**即s1 len部分为{3,4,5,6}cap部分还包括了arr后面的{7,8} 所以s2可以取到{7}这个数**
**slice只能向后扩展，不能向前扩展**
**s1[index]不能超越len 向后扩展不能超越cap**

所以刚才的两个slice是这样的

```go
s1:=arr[2:6]  // {3,4,5,6} len=4 cap=6
s2:=s1[3:5]   //{6,7} len=2 cap=3
```

### 2.5 slice 删除元素

```go
s1:=[]{1,2,3,4,5} 
// 删除s1中的元素3
s1=append(s1[:2],s1[3:]...)
// 即将s1中的前两个元素 和第3个元素后面的元素从新组成一个新的切片
// 其中 append 函数第二个参数是一个可变参数，可以接收多个值 传入切片或数组时后面加三个点即表示传入切片或数组中的所有值
```

### 2.6 string和slice

* string底层是byte数组，因此string也可以进行切片处理

```go
	str:="hello go"
	slices:=str[6:]
	fmt.Println(slices) //go
```

string类似slice，也是包含一个指针和长度，指针指向底层byte数组

切片slices则指向byte数组下标为6的元素的地址

* string是不可变的

`str[0]="a"` 这种写法是错的

* 如何修改字符串

如果需要修改字符串，那么可以

1.先将字符串转为[]byte或者[]rune

> byte按字节处理的 只能处理英文和数字 汉字占3个字节 
>
> []rune按字符处理 所以处理汉字需要转为[]rune

2.修改

3.转回string

```go
	//[]byte英文+数字
	arr1:=[]byte(str) //1.将字符串转为[]byte
	arr1[6]='G' 	  //2.修改
	str=string(arr1)  //3.转回string
	fmt.Println(str)
	//[]rune 汉字
	arr2 := []rune(str)  //1.将字符串转为[]rune
	arr2[6] = '白'		//2.修改
	str = string(arr2)   //3.转回string
	fmt.Println(str)
```

