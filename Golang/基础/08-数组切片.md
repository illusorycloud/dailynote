# 数据类型

## 数组

语法格式

go语言声明数组需要指定**元素类型**及**元素个数**

```go
//一维数组
var 变量名 [数组长度]数据类型
```

数组长度必须大于0，数组一旦定义，大小不能更改。

未初始化的数组不是nil，没有空数组（与slice的区别）//未初始化有默认值 根据类型不同而不同

### 初始化数组

```go
var nums =[5]int{1,2,3,4,5}
//忽略[]中的数字 由编译器根据后面的元素个数来计算数组长度
var nums =[...]int{1,2,3,4,5} //这里...会自动替换为5
```

## 切片

### 简介

**go语言切片是对数组的抽象，切片没有自己的数据，它只是底层数组的一个引用，对切片的所有修改都将反应在底层数组中**。

数组是值类型，切片是个引用类型。

go中数组长度不可变，在特定场合中不够灵活，于是提供了一种灵活、功能强悍的内置类型切片。

* 与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容置增大 

* 切片本身没有任何数据，它们只是对现有数组的引用。

* 切片与数组相比，不需要设定长度，在1 中不用设定值，相对来说比较自由 

* **从概念上面来说slice像一个结构体**，这个结构体包含了三个元素：

  * **指针**，指向数组中slice指定的开始位置 
  * **长度**，即slice的长度
  * **最大长度/容量**，也就是slice开始位置到数组的最后位置的长度

  ```go
  type slice struct{
      ptr *[2]int //    ptr *[2]int //d
      len int
      cap int
  }
  ```

  

### 切片的声明

#### 1. 直接声明切片

声明一个未指定长度的数组来定义切片 

* var identifier [I type 
* 切片不需要说明长度。
* 该声明方式，且未初始化的切片为空切片。该切片默认为nil,长度为0。

```go
//声明切片1 未初始化时为nil
var s1 []int
```

#### 2. make方式声明

* 1.通过make方式创建切片可以指定大小和容量
* 2.如果没给切片的各个元素赋值，那么会使用默认值
* 3.通过make方式创建的切片对应的数组由make底层维护，对外不可见，即只能通过slice访问

```go
//声明切片2.1 make方式声明的切片不为nil 有默认值 这里int型默认值为0
var s2 []int = make([]int, 5)
var s3 []int = make([]int, 5, 7)
```

#### 3. 直接赋值

 ```go
var s6 []int=[]int{1,3,4,5,7}  //len=5 cap=5
 ```

这种方式声明的切片len和cap等于元素个数。

### append 动态扩容

切片底层是指向的一个数组，扩容原理分析：

1.切片 append 操作本质是对数组扩容

2.go 底层会创建一个新的数组 newAr(按照扩容后的大小)

3.将 slice 原来包含的元素拷贝到新的数组 newArr

4.slice 重新引用到 newArr

5.注意 newArr 是在底层维护的，程序员不可见

### copy 切片拷贝

```go
//将src拷贝到dst 必须两者都是切片类型才能拷贝
copy(dst,src)
```

```go
var s6 []int = []int{1, 3, 4, 5, 7} 	
s4 := make([]int, 5) //全是默认值 {0,0,0,0,0}

fmt.Println(s4)//拷贝之前 [0 0 0 0 0]
copy(s4,s6) //将s6拷贝到s4
fmt.Println(s4)//拷贝之后 [1 3 4 5 7]

```

**可以将大切片拷贝给小切片**

```go
var s1 []int = []int{1, 3, 4, 5, 7} 	
s2 := make([]int, 1) //全是默认值 [0]
copy(s2,s1) //将s1拷贝到s2 由于s2长度为1 所以最终只会拷贝1个元素 但是不会报错
fmt.Println(s2） //[1]
```

### string和slice

* string底层是byte数组，因此string也可以进行切片处理

```go
	str:="hello go"
	slices:=str[6:]
	fmt.Println(slices) //go
```

string类似slice，也是包含一个指针和长度，指针指向底层byte数组

切片slices则指向byte数组下标为6的元素的地址

* string是不可变的

`str[0]="a"` 这种写法是错的

* 如何修改字符串

如果需要修改字符串，那么可以

1.先将字符串转为[]byte或者[]rune

> byte按字节处理的 只能处理英文和数字 汉字占3个字节 
>
> []rune按字符处理 所以处理汉字需要转为[]rune

2.修改

3.转回string

```go
	//[]byte英文+数字
	arr1:=[]byte(str) //1.将字符串转为[]byte
	arr1[6]='G' 	  //2.修改
	str=string(arr1)  //3.转回string
	fmt.Println(str)
	//[]rune 汉子
	arr2 := []rune(str)  //1.将字符串转为[]rune
	arr2[6] = '白'		//2.修改
	str = string(arr2)   //3.转回string
	fmt.Println(str)
```

