# Golang的GPM模型

#### 概述

M关联了一个内核线程，通过调度器P（上下文）的调度，可以连接1个或者多个G,相当于把一个内核线程切分成了了N个用户线程，M和P是一对一关系（但是实际调度中关系多变），通过P调度N个G（P和G是一对多关系），实现内核线程和G的多对多关系（M:N），通过这个方式，一个内核线程就可以起N个Goroutine，同样硬件配置的机器可用的用户线程就成几何级增长，并发性大幅提高

#### 运行情况

- 1.此时有一个系统线程`M0`正在执行协程`G0`，另外三个协程`G1 G2 G3`在队列等待。
- 2.如果`G0`协程阻塞,比如读取文件或者数据库等
- 3.这时就会创建`M1`主线程(也可能是从己有的线程池中取出), 将等待的3个协程挂到`M1`开始执行，`M0`主线程下的`G0`仍然执行文件IO的读写。
- 4.这样的MPG调度模式，可以既让`G0`执行，同时也不会让队列的其它协程一直阻塞，仍然可以并发/并行执行。
- 等到`G0`不阻塞了，`M0`会被放到空闲的主线程继续执行(从已有的线程池中取)，同时`G0`也会被唤醒。

#### 局部G队列与全局G队列的关系

- 全局G任务队列会和各个本地G任务队列按照一定的策略互相交换。没错，就是`协程任务`交换
- G任务的执行顺序是，先从本地队列找，本地没有则从`全局队列`找
- 转移
  - 局部与全局，全局G个数 / P个数
  - 局部与局部，一次性转移一半

#### Gorutine从入队到执行

1. 当我们创建一个G对象，就是 `gorutine`，它会加入到本地队列或者全局队列

2. 如果还有空闲的P，则创建一个M 绑定该 P ，注意！这里，P 此前必须还没绑定过M 的，否则不满足空闲的条件。细节点：

   1. 先找到一个空闲的P，如果没有则直接返回

   2. P 个数不会占用超过自己设定的cpu个数

   3. P 在被 M 绑定后，就会初始化自己的 G 队列，此时是一个`空队列`

   4. 注意这里的`一个点`

      - 无论在哪个 M 中创建了一个 G，只要 P 有空闲的，就会引起新 M 的创建
      - 不需考虑当前所在 M 中所绑的 P 的 G 队列是否已满
      - 新创建的 M 所绑的 P 的初始化队列会从其他 G 队列中取任务过来

   5. 这里留下第一个问题：

      > 如果一个G任务执行时间太长，它就会一直占用 M 线程，由于队列的G任务是顺序执行的，其它G任务就会阻塞，如何避免该情况发生？ --①

3. M 会启动一个`底层线程`，`循环执行`

   能找到的 G 任务。这里的寻找的 G 从下面几方面找：

   - 当前 M 所绑的 P 队列中找
   - 去别的 P 的队列中找
   - 去全局 G 队列中找

4. G任务的执行顺序是，先从本地队列找，本地没有则从全局队列找

5. 程序启动的时候，首先跑的是主线程，然后这个主线程会绑定第一个 P

6. 入口 main 函数，其实是作为一个 goroutine 来执行

#### 解答问题-①

协程的切换时间片是10ms，也就是说 goroutine 最多执行10ms就会被 M 切换到下一个 G。这个过程，又被称为 `中断，挂起`

原理：

go程序启动时会首先创建一个特殊的内核线程 `sysmon`，用来监控和管理，其内部是一个循环：

1. 记录所有 P 的 G 任务的`计数 schedtick`，schedtick会在每执行一个G任务后递增
2. 如果检查到 `schedtick` 一直没有递增，说明这个 P 一直在执行同一个 G 任务，如果超过10ms，就在这个G任务的栈信息里面加一个 tag 标记
3. 然后这个 G 任务在执行的时候，如果遇到非内联函数调用，就会检查一次这个标记，然后中断自己，把自己加到队列末尾，执行下一个G
4. 如果没有遇到`非内联函数` 调用的话，那就会一直执行这个G任务，直到它自己结束；如果是个死循环，并且 GOMAXPROCS=1 的话。那么一直只会只有一个 P 与一个 M，且队列中的其他 G 不会被执行！

例子，下面的这段代码，`hello world` 不会被输出

```go
func main(){
    runtime.GOMAXPROCS(1)
    go func(){
        fmt.Println("hello world")
        // panic("hello world")  // 强制观察输出
    }()
    go func(){
        for {
            // fmt.Println("aaa")  // 非内联函数，这行注释打开，将导致 hello world 的输出
        }
    }()
    select {}
}
```

#### 中断后的恢复

1. 中断的时候将寄存器里的栈信息，保存到自己的 G 对象里面
2. 当再次轮到自己执行时，将自己保存的栈信息复制到寄存器里面，这样就接着上次之后运

#### GOMAXPROCS--性能调优

看完上面的内容，相信你已经知道，`GOMAXPROCS` 就是 go 中 runtime 包的一个函数。它设置了 P 的最多的个数。这也就直接导致了 M 最多的个数是多少，而 M 的个数就决定了各个 G 队列能同时被多少个 M 线程来进行调取执行！

故，我们一般将 GOMAXPROCS 的个数设置为 CPU 的核数，且需要注意的是：

- go 1.5 版本之前的 GOMAXPROCS 默认是 1
- go 1.5 版本之后的 GOMAXPROCS 默认是 Num of cpu



## 参考

`https://www.cnblogs.com/linguanh/p/9510746.html`

