---
layout: post
title: Java基础
categories: Java
description: 网上找的一些关于Java基础的题
keywords: Java, base
---

1、在Java语言中多态性体现在由方法重载实现的静态多态性和方法重写实现的动态多态性。

2、final 类不能被继承，即不能有子类。    

3、abstract 类不能创建对象，必须产生其子类，由子类创建对象。 

4、如果一个方法被修饰为 final 方法，则这个方法不能被重写。    

5、对于 abstract 方法，只允许声明，而不允许实现。    

6、如果一个方法被修饰为final方法，则这个方法不能被重写 。    

7、如果一个类是一个abstract类的子类，它必须具体实现父类   的abstract方法。    

8、局部变量的名字与成员变量的名字相同，若想在该方法内使用成员变量，必须使用关键字   this 。   

 9、在关键字中能代表当前类或对象本身的是 this 。    

10、如果在子类中想使用被子类隐藏的父类的成员变量或方法可以使用关键字 super   。  

11、子类如果想用父类的构造方法，必须在子类的构造方法中使用，并且必须使用关键字   super 来表示。    

12、如果在子类中想使用被子类隐藏了的父类成员变量或方法就可以使用关键字super。 

13、Java中为了克服单继承 的缺点，使用了接口，一个类可以实现多个接口。    

14、接口 就是方法定义和常量值的集合。    

15、使用关键字 interface 来定义接口。    

16、接口定义包括接口的声明和接口体 。    

17、一个类通过使用关键字 implements 声明自己实现一个或多个接口。    

18、如果一个类实现了某个接口，那么这个类必须实现该接口的所有方法 。    

19、接口中的方法被默认的访问权限是 public 。 

20、接口的定义包括接口声明 和接口体。    

21、定义接口时，接口体中只进行方法的声明，不允许提供方法的实现 。    

22、如果接口中的方法的返回类型不是void的，那么在类中实现该接口的方法时，方法体至少要有一个   return 语句。    

23、内部类 指那些类定义代码被置于其他类定义中的类。    

24、泛型 是Java SE5.0的新特性。    

25、创建对象常用的方法就是使用 new 运算符和类的构造方法。    

26、把Java应用程序中涉及到的类压缩成一个 jar 文件。    

27、数组 是相同类型的数据按顺序组成的一种引用数据类型。    

28、Java中定义数组后通过数组名 加数组下标，来使用数组中的数据。    

29、Java中声明数组包括数组的名字、数组包含的元素的数据类型 。    
30、声明数组   仅仅是给出了数组名字和元素的数据类型，要想真正的使用数组还必须为它分配内存空间。 

31、一维数组通过下标符访问自己的元素，需要注意的是下标从 0 开始。    

32、创建数组后，系统会给每一个数组元素一个默认的值，如float型是 0 。    

33、声明数组仅仅是给出了数组名字和元素的数据类型，要想真正地使用数组还必须为它分配内存空间。

34、数组声明后，必须使用 new 运算符分配内存空间。    

35、Java中使用java.lang包中的 String   类来创建一个字符串变量，因此字符串变量是类类型变量，是一个对象。    36、创建一个字符串时，使用String类的构造方法 。    

37、String 类是不可变类，对象所包含的字符串内容永远不会被改变。    

38、StringBuffer   类是可变类，对象所包含的字符串内容可以被添加或修改。   

39、使用String类的 length() 方法可以获取一个字符串的长度。    

40、可以使用String类的 startsWith(String s)   方法判断一个字符串的前缀是否是字符串s。    

41、可以使用String类的 endsWith(String s)   方法判断一个字符串的后缀是否是字符串s。    

42、可以使用String类的 equals(String s)   方法比较一字符串是否与字符串s相同。    

43、字符串调用 indexOf(String s)   方法从当前字符串的头开始检索字符串s，并返回首次出现  s的位置。    

45、字符串调用indexOf方法检索字符串s，并返回首次出现s   的位置。如果没有检索到字符串s，该方法返回的值是 -1 。    

46、一个字符串s 通过调用方法 trim()   得到一个字符串对象，该字符串对象是s 去掉前后空格后的字符串。    47、java.lang 包中的Integer 类调用其类方法：    

48、parseInt 可以将“数字”格式的字符串，如“12387”，转化为int   型数据。    

49、可以使用java.lang包中的 Integer   类将形如“12387”的字符串转化为int型数据。    
50、可以使用java.lang包中的 Long 类将字符串转化为long型数据。   

 51、可以使用String类直接调用 valueOf 方法将数值转化为字符串。    

52、StringBuffer类调用方法， toString()   返回缓冲区内的字符串。    

53、Object类有一个public方法是 toString   ，一个对象通过调用该方法可以获得该对象的字符串表示。    

54、Object 类是所有Java   类的最终祖先，如果一个类在声明时没有包含extends 关键词，那么这个类直接继承Object类。   

 55、对于一个已经不被任何引用变量引用的对象，当垃圾回收器准备回收该对象所占用的内存时，将自动调用该对象的   finalize() 方法。    

56、每个Java 基本类型在java.lang 包中都有一个相应的包装   类，把基本类型数据转换为对象。    

57、在Java 集合中不能存放基本类型数据，如果要存放数字，应该使用包装类型 。    

58、Character 类和Boolean 类直接继承Object   类，除此以外，其他包装类都是 java.Number 的直接子类。59、包装类都覆盖了Object 类的 toString()   方法，以字符串的形式返回包装对象所表示的基本类型数据。    
60、所有的包装类都是final 类型，因此不能创建它们的子类 。    

61、Math 类提供了许多用于数学运算的静态方法。    

62、Math 类是 final 类型的，因此不能有子类。   

63、Random 类提供了一系列用于生成随机数的方法。    

64、Date 类以毫秒数来表示特定的日期。    

65、java.text.DateFormat 抽象类用于定制日期的格式，   它有一个具体子类为 SimpleDateFormat 。    

66、BigDecimal   类能够进行浮点数的精确加法、减法和乘法运算，对于浮点数的除法运算，可以满足用户指定的精度。    

67、异常处理   方法是一种非常有用的辅助性程序设计方法。采用这种方法可以使得在程序设计时将程序的正常流程与错误处理分开，有利于代码的编写和维护。    

68、按异常在编译时是否被检测来分，异常可以分为两大类：受检异常与非受检异常 。    

69、程序可以处理的异常对应的类是 Exception 及其子类。    
70、抛出异常可以利用 throw 语句。    

71、处理异常的方式有两种：捕捉异常 方式与转移异常方式。    

72、捕捉异常方式是通过 try-catch-finally 结构处理异常。    

73、在try-catch-finally 结构中， finally   语句块一般总是会被执行，不管有没有异常产生。    

74、异常处理流程中，其中 try 代码块包含了可能发生异常的程序代码。    

75、异常处理流程中，其中 catch 代码快紧跟在try   代码块后面，用来捕获并处理异常。  

76、异常处理流程中，其中 finally 代码块用于释放被占用的相关资源。    

77、对于程序中可能出现的受检查异常，要么用try…catch   语句捕获并处理它，要么用 throw 语句抛出它，Java 编译器会对此做检查。    

78、File 对象调用方法 mkdir() 创建一个目录。   

79、文件输入流（输入流的子类）提供对文件的存取。为了读取文件，使用文件输入流构造方法来打开   一个到达该文件的输入流。    

80、输入流试图要打开的文件可能不存在，就出现I/O 错误，Java   生成一个出错信号，它使用一个 IOException 对象来表示这个出错信号。    

81、read 方法给程序提供一个从输入流中读取数据的基本方法。    

82、read   方法从输入流中顺序读取源中的单个字节数据，该方法返回字节值（0~255 之间的一个整数），如果到达源的末尾，该方法返回 -1 。 

83、虽然Java   在程序结束时自动关闭所有打开的流，但是当我们使用完流后，显式地关闭 任何打开的流仍是一个良好的习惯。    

84、在操作系统把程序所写到输出流上的那些字节保存到磁盘上之前，内容有时被存放在内存缓冲区中，通过调用   close() 方法，可以保证操作系统把流缓冲区的内容写到它的目的地。    

85、java.lang 包中的System 类有两个重要的类成员：in 和   out ，分别是输入流和输出流类型的对象。    

86、FileInputStream 使用字节   读取文件，不能直接操作Unicode 字符。    

87、RandomAccessFile 类中用 seek   方法，来定位RandomAccessFile 流的读写位置。 

88、Java的抽象窗口工具包中包含了许多类来支持 GUI 设计。    

89、JButton类、JLabel类是包javax.swing中的类，并且是javax.swing包中的   JComponent 的子类。    

90、Java把有JComponent类的子类或间接子类创建的对象称为一个swing组件   。    

91、javax.swing包的类 JPanel 是用来建立面板的。    

92、javax.swing包中的 JScrollPane   类也是JContainer类的子类，该类创建的对象也是一个容器，称为滚动窗口。    

93、javax.swing包中的 JFrame   类或子类所创建的一个对象就是一个窗口。   

 94、Java程序中可以向容器添加组件，一个容器可以使用 add()   方法将组件添加到该容器中。    

95、在组件类的一些常用方法中 setBackground   方法是设置组件的背景颜色。    

96、在组件类的一些常用方法中 setForeground   方法是设置组件的前景颜色。    

97、Java中JFrame类的 setTitle 方法是用来设置窗口的名字。    

98、JFrame类创建的对象是一个窗口容器，它默认布局是   BorderLayout 布局。    

99、JPanel 的默认布局管理器是 FlowLayout 。  

100、Java的java.awt包中定义了5种布局类，分别是FlowLayout、BorderLayout、CardLayout、   GridLayout 和GridBagLayout。    

101、Java的java.awt包中定义了5种布局类，分别是FlowLayout、BorderLayout、   CardLayout 、GridLayout和GridBagLayout。    

102、FlowLayout   对应的布局是容器将其中的组件按照加入的先后顺序从左向右排列。   

103、BorderLayout   对应的布局是把容器内的空间简单地划分为东、西、南、北、中5个区域，每加入一个组件都应该指明把这个组件加在哪个区域中。    

104、GridLayout   是使用较多的布局编辑器，其基本布局策略是把容器划分成若干行乘若干列的网格区域，组件就位于这些划分出来的小格中。 

105、FlowLayout、GridLayout、BordrLayout布局对象都可以使用方法setVgap(intvgap)设置当前布局中组件的垂直间距   。   

106、FlowLayout、GridLayout、BordrLayout布局对象都可以使用方法setHgap(inthgap)设置当前布局中组件的水平间距   。    

107、使用 CardLayout   布局的容器可以容纳多个组件，但实际上同一时刻容器只能从这些组件中选出一个来显示。    

108、Java中能够产生事件的对象都可以成为事件源 ,如文本框、按钮、键盘等。    

109、Java中事件源发生事件时，监视器 就自动调用执行被类实现的某个接口方法。    

110、当用户与GUI 交互，比如移动鼠标、按下鼠标键、单击Button   按钮、在文本框内输入文本、选择菜单项或者关闭窗口时，GUI 会接受到相应的事件 。    

111、Java中，监听器 负责接收和处理这种事件。    

112、Java中为了能监视到ActionEvent类型的事件，事件源必须使用   addActionListener() 方法获得监视器。

113、只要用户单击JButton，就会触发一个ActionEvent   事件，该事件被监听器接收，它的方法 	   `actionPerformed()` 被执行。    

114、在监听类的事件处理方法中通过事件类的 getSource()   方法来获得事件源。    

115、Java的 java.awt.event   包中包含了许多用来处理事件的类和接口。    

116、鼠标事件类MouseEvent中的方法getSource()是获取发生鼠标事件的事件源   。    

117、使用MouseListener接口处理鼠标事件，事件源发生的鼠标事件有5种，按下鼠标键、释放   鼠标键、点击鼠标键、鼠标进入和鼠标退出。    

118、鼠标事件的类型是 MouseEvent   ，即当发生鼠标事件时，该类自动创建一个事件对象。    

119、使用MouseListener接口处理鼠标事件，鼠标事件源发生的鼠标事件包括，按下鼠标键、释放鼠标键、单击   鼠标键、鼠标进入和鼠标退出。    

120、MouseMotionListener 和MouseListener   都监听 MouseEvent 事件。    

121、javax.swing包中的 JButton   类专门用来建立按钮，即它的实例对象就是一个按钮。 

122、在JButton类中， getText() 方法是用来获取按钮上的名字。    

123、在javax.swing中 JLabel   类使用来创建标签的，即它的一个实例就是一个标签。    

124、在javax.swing包中的 JTextField   类是专门用来建立文本框，它的一个对象就是一个文本框。    

125、Java中文本框类的 setText(String s)   方法是在文本框中设置文本。    

126、Java中文本框类的 getText() 方法是获取文本框中的文本。    

127、Java中标签类的 setText(String s)   方法是设置标签的名字。    

128、Java中标签类的 getText() 方法是获取标签的名字。    

129、Java中 JTextArea   类是专门用来建立文本区的，即它的一个对象就是一个文本区。 

130、javax.swing包中的 JCheckBox   类是专门用来建立选择框的。    

131、在JCheckBox类中， isSelected   方法是用来返回选择框的布尔状态。    

132、javax.swing包中的类 JList 类是专门用来建立列表框。    

133、对话框与一般窗口的区别在于它必须依赖 于其他窗口。    

134、对话框分为两种，如果有模式   对话框被显示，那么其他窗口都处于不活动状态，只有当用户关闭了对话框，才能操纵其他窗口。    

135、对话框分为两种，如果无模式 对话框被显示，其他窗口照样处于活动状态。    

136、在对话框类Dialog中的方法setModal(boolean)的作用是设置对话框的模式   。    

137、在对话框类Dialog中的方法 setSize() 是设置对话框的大小。    

138、对话框的默认布局是 BorderLayout   布局，在创建对话框时必须有对话框大小的设置。 

139、FileDialog 是Dialog类的子类，它创建的对象称为文件对话框。    

140、FileDialog是Dialog类的子类，它创建的对象称为文件对话框 。   

141、Java开发程序大多是单线程 的，即一个程序只有一条从头至尾的执行线索。    

142、多线程 是指同时存在几个执行体，按几条不同的执行线索共同工作的情况。    

143、线程 是指进程中的一个执行流程。   

144、一个进程在其执行过程中，可以产生多个线程 ，形成多条执行线索。    

145、每个java程序都有一个默认的主线程 。    

146、对于java应用程序，主线程都是从 main 方法执行的线索。    

147、在java中要想实现多线程，必须在主线程中创建新的线程对象 。    

148、当一个线程处于创建 状态时，它仅仅是一个空的线程对象，系统不为它分配资源。  

149、一个正在执行的线程可能被人为地中断，让出CPU   的使用权，暂时中止自己的执行，进入阻塞 状态。    150、处于死亡 状态的线程不具有继续运行的能力。    

151、处于就绪   状态的线程首先进入就绪队列排队等候处理器资源，同一时刻在就绪队列中的线程可能有多个。    

152、在线程排队时，优先级高   的线程可以排在较前的位置，能优先享用到处理器资源，而其他线程只能排在它后面再获得处理器资源。    

153、对于优先级相同的线程，遵循队列的先进先出 原则被分配给处理器资源。   

154、Java语言使用 Thread 类及其子类的对象来表示线程。    

155、线程调度管理器   负责管理线程排队和处理器在线程间的分配，一般都配有一个精心设计的线程调度算法。    

156、在java系统中，线程调度依据优先级基础上的先到先服务 原则。    

157、当生成一个 Thread 类的对象之后,一个新的线程就产生了。    

158、Java 中编程实现多线程应用有两种途径：一种是用Thread   类的子类创建线程，另一种是用Thread 类结合 Runnable 接口创建线程。    

159、Thread 类综合了Java 程序中一个线程需要拥有的属性和方法。    

160、start()   方法将启动线程对象，使之从新建状态转入就绪状态并进入就绪队列排队。 

161、当 run   方法执行完毕，线程就变成死亡状态，所谓死亡状态就是线程释放了实体，即释放分配给线程对象的内存。    

162、利用构造   方法创建新线程对象之后，这个对象中的有关数据被初始化，从而进入线程生命周期的新建状态。    

163、优先级高的线程可以在它的run()方法中调用 sleep()   方法来使自己放弃处理器资源，休眠一段时间。    

164、Java多线程使用中，调用 currentThread   方法可确定当前占有CPU的线程。    

165、当用Thread   类的构造方法Thread(Runnabletarget)创建线程对象时，构造方法中的参数必须是一个具体的对象，该对象称作线程的目标对象 。    

166、当线程调用start   方法时，一旦轮到它来享用CPU，目标对象就会自动调用接口中的 run 方法。    

167、一个实现了 Runnable   接口的类实际上定义了一个主线程之外的新线程的操作。    168、Thread 类代表线程类，它的方法 run()   ―包含线程运行时所执行的代码。    

169、Thread 类代表线程类，它的方法 start() 用于启动线程。    

170、Java   提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程。线程调度器按照线程的优先级 决定应调度哪些线程来执行。    

171、在独占   方式下，当前活动线程一旦获得执行权，将一直执行下去，直到执行完毕或由于某种原因主动放弃CPU，或者是有一高优先级的线程处于就绪状态。

172、线程调用了yield()或 sleep() 方法主动放弃CPU。

173、线程的优先级用数字来表示， 范围从1到10。174、一个线程的缺省优先级是 5 。    

175、使用多线程时，有时需要协调两个或多个线程的活动。使线程协调工作的过程称为同步化   。    

176、可以通过使用 synchronized   关键词修改方法来同步化对方法的访问。    177、线程中， wait 的作用:释放已持有的锁,进入等待队列。    

178、线程中， notify 的作用：唤醒wait   队列中的第一个线程并把它移入锁申请队列。  

179、线程中， notifyAll 的作用：唤醒wait   队列中的所有的线程并把它们移入锁申请队列。



 感觉自己是真的菜,好多都不会，赶紧复习下呢。

![java-base](https://github.com/lillusory/lillusory.github.io/raw/master/images/posts/Java/Java_base.jpg)

