# 数据模型设计

## 1. 概述

数据模型包括以下3个元素：

* 1）实体
  * 描述业务的主要数据集合
* 2）属性
  * 描述实体里面的单个信息
* 3）关系
  * 描述实体与实体之间的数据规则
  * 结构规则：1-N、N-1、N-N
  * 引用规则：比如电话号码不能单独存在，必须和某个联系人绑定



## 2. 建模阶段

建模过程可以大致分为如下3个阶段：

* 1）概念建模
  * 只有一个大致概念，比如要设计一个 联系人管理 系统。
* 2）逻辑建模
  * 在概念模型基础上进一步细化。比如 联系人管理系统肯定有 联系人、分组关系等等信息
* 3）物理建模
  * 具体落实到数据表设计上。
  * 联系人表、分组关系表等等



物理模型分类如下：

* 1）关系模型
  * 关系型数据库
  * 第三范式
* 2）文档模型
  * 不循序第三范式，允许冗余。



## 3. 文档模型

设计原则：性能和易用两个点。



|              | 关系型数据库                 | JSON文档模型       |
| ------------ | ---------------------------- | ------------------ |
| 模型设计层次 | 概念模型、逻辑模型、物理模型 | 概念模型、逻辑模型 |
| 模型实体     | 表                           | 集合               |
| 模型属性     | 列                           | 字段               |
| 模型关系     | 关联关系，主外键             | 内嵌数组，引用字段 |



## 4. MongoDB 文档模型设计三部曲

* 1）基础建模
  * 根据业务需求和逻辑模型进行设计
  * 定义字段、集合、基础形状等
* 2）工况细化
  * 根据技术需求、系统读写比例、方式及数量等进行调整
  * 确定引用及关联
* 3）套用设计模式
  * 根据经验和学习进行优化
  * 完成最终模式



### 1. 建立基础文档模型

具体步骤如下：

1. 根据概念模型或者业务需求推导出逻辑模型-找到对象
2. 列出实体之间的关系(及基数) - 明确关系
3. 套用逻辑设计原则来决定内嵌方式-进行建模
4. 完成基础模型构建

例子：

还是使用之前联系人的例子

1.找到对象

* 联系人
* 分组
* 地址
* 头像

2.明确关系

* 一个联系人有一个头像（1-1）
* 一个联系人有多个地址（1-N）
* 一个联系人可以属于多个分组，一个分组可以有多个联系人（N-N）



基本原则

**一对一关系**以内嵌为主，作为子文档形式或者直接作为字段放在顶级，不涉及到数据冗余。

> 例外情况：如果内嵌后导致文档大小超过 16MB 则不能内嵌。MongoDB 限制单文档最大不超过 16MB。

```json
# protraits 字段内嵌文档
name: "17x",
protraits:{
    mimetype: xxx,
    data: xxx
},
```







**一对多关系**同样以内嵌为主，用数组来表示一对多，不涉及到数据冗余。

> 例外情况：1.文档大小超过 16MB，2.数组长度太大（超过1万），3.数组长度不确定

```json
# address 内嵌数组
name: "17x",
protraits:{
    mimetype: xxx,
    data: xxx
},
address: [
    {type: home,...},
     { type: work,...}
],
```



**多对多关系**有所不同：

* 1）不需要映射表
* 2）一般用内嵌数组来表示一对多
* 3）通过冗余在实现多对多

> 例外情况：1.文档大小超过 16MB，2.数组长度太大（超过1万），3.数组长度不确定

```json
# groups 冗余
name: "17x",
protraits:{
    mimetype: xxx,
    data: xxx
},
address: [
    {type: home,...},
     { type: work,...}
],
groups: [
    {name: "Friends"},
    {name: "Surfers"}
],
```



### 2. 根据读写工况细化

这一步主要根据 技术需求、读写比例、方式及数量对上一步的模型进行优化。

* 最频繁的数据查询模式

* 最常用的查询参数
* 最频繁的数据写入模式
* 读写操作的比例
* 数据量的大小

基于内嵌的文档模型，根据业务需求,使用引用来避免性能瓶颈，使用冗余来优化访问性能。



联系人的例子，需求如下

* 用于客户营销
* 有千万级联系人
* 需要频繁变动分组的信息，如增加分组及修改名称描述和营销状态等
* 一个分组可以有百万级联系人



**问题1：分组**

之前分组使用内嵌方式，需求中会频繁调整分组信息，那么每次都会有大量DB操作。

解决： 分组使用单独的集合。

1. 类似与关系型设计
2. 用Id或者唯一建关联
3. 使用 $lookup 来提供一次查询多表的能力。

```json
# group_ids 管理
name: "17x",
protraits:{
    mimetype: xxx,
    data: xxx
},
address: [
    {type: home,...},
     { type: work,...}
],
group_ids: [ 1,2,3],

# group表 通过 group_id 进行管理
group_id:1,
name:Friedns
```



**问题2：头像**

之前头像也是内嵌的，

* 头像是高清的，很大（5M、10M甚至更大）
* 很少更换头像
* 一般只查询基本信息，很少查询头像（大致比例9:1）

使用**引用方式**，把头像数据放到另外一个集合，可以显著提高查询效率。

```json
name: "17x",
protraitid: 123,

# 头像表 protrait
_id:123,
mimetype: xxx,
data: xxx
```



**什么时候使用引用方式？**

* 1）内嵌文档**太大**，数MB或超过16MB
* 2）内嵌文档或数组元素会**频繁修改**
* 3）内嵌数组元素会**持续增长并且没有封顶**

**MongoDB引用设计限制**

* MongoDB对使用引用的集合之间并无主外键检查
* MongoDB使用聚合框架的$lookup来模仿关联查询
* $lookup只支持left outer join
* $lookup关联目标不能是分片表





### 3. 套用设计模式

文档模型:无范式，无思维定式，充分发挥想象力

设计模式:实战过屡试不爽的设计技巧，快速应用

举例: 一个loT场景的分桶设计模式，可以帮助把存储空间降低10倍并且查询效率提升数十倍.

记录航班的飞行状态，每分钟记录一条数据。

10W架飞机，1年的数据就是 `10W*365*24*60=520亿`。

每个文档内容不多，但是文档数很多，加上索引还是会占用4500GB左右的大小。

如果用数组内嵌的方式，每个小时记录一个文档，然后数组中存60个元素，每个元素就是每分钟的数据。

这样文档数直接变成六十分之一，由于文档数少了，所以索引的数量也变小了，最终只需要600GB左右空间。



### 分桶模式

* 场景
  * 时序数据
  * 物联网
  * 等等
* 痛点
  * 数据采集频繁，数据量太多
* 设计模式的方案及优点
  * 利用文档内嵌数组，将一个时间段的数据聚合到一个文档里
  * 大量减少文档数量
  * 大量减少索引占用空间





## 5. 优秀文档设计模式



### 1. 列转行

大文档，很多字段，大部分字段都因为查询需要建立索引。

比如，电影上映日期，每个国家地区可能不一样，但是查询的时候每个国家都有可能被查询到。

```json
title: "Dunkirk",
...
release_USA: "2020/07/23",
release_UK: "2020/07/25",
release_France: "2020/07/29",
```

这样就需要为 release_USA、release_UK、release_France 等等字段都创建一个索引。

使用列转行模式后：

```json
title:"Dunkirk",
...
release:[
    { country:"USA",date: "2020/07/23"},
    { country:"UK",date: "2020/07/25"},
    { country:"France",date: "2020/07/29"},
]
```

这样只需要创建`release.country` 和`release.date` 这两个索引就能替代之前几十上百个索引。

* 场景
  * 产品属性：color、size ...
  * 多语言（多国家）
* 痛点
  * 文档中有很多类似字段
  * 会用于组合搜索，需要建立多个索引。
* 设计模式方案及优点
  * 转化为数组，一个索引解决索引查询问题



### 2. 版本字段

MongoDB是文档数据库，所以可以很方便的增删字段。

但是经过几个版本增删字段后，可能数据库里同时存在了多个版本的数据，字段都不一样，很难管理。

所以可以增加一个版本字段。

* 场景
  * 任何有版本衍变的数据库
* 痛点
  * 文档模型格式多，无法知道其合理性
  * 升级时需要更新太多文档
* 设计模式方案及优点
  * 增加一个版本号字段
  * 快速过滤掉不需要升级的文档
  * 升级时可以对不同版本文档做不同处理





### 3. 近似计算

问题：统计页面点击量，如果每次点击都记录一次，那么用户量大时会产生大量的数据库写入。

这种不需要精确值的统计情况就可以使用近似计算。

比如每10个点击才记录一次，伪代码如下

```go
if random(0,9)==0
	increment by 10
```

这样就能减少10倍的写入，但是最终的结果不会有太大变化，大致上是差不多的。

* 场景
  * 网页计数
  * 各种结果不需要准确的排名
* 痛点
  * 写入太频繁，消耗系统资源
* 设计模式方案及优点
  * 间隔写入，每隔10次或100次
  * 大量减少写入请求



### 4. 预聚合字段

问题：业绩排名、游戏排名、商品统计等精确统计。

* 比如某个商品今天卖了多少，这星期卖了多少，这个月卖了多少
* 电影的观影人次统计排名等

传统解决方案：聚合查询

痛点：消耗资源多，聚合计算时间长（分钟级）



比如在商品表中直接增加`daily_sales`、`week_sales`、`monthly_sales`等字段，每次卖出商品时都更新这些字段。

这样查询时可以直接读取，不需要进行聚合操作。



* 场景
  * 准确排名
  * 排行榜
* 痛点
  * 聚合统计耗时长
* 设计模式方案及有点
  * 模型中直接增加统计字段
  * 每次更新数据时同步更新统计值



