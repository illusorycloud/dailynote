
最近在研究Java的动态代理时对InvocationHandler中invoke方法中的第一个参数一直不理解它的用处
1. 可以使用反射获取代理对象的信息（也就是proxy.getClass().getName()）。

2. 可以将代理对象返回以进行连续调用，这就是proxy存在的目的，因为this并不是代理对象。


静态代理和装饰者模式区别

代理模式和装饰者模式有着很多的应用，这两者具有一定的相似性，都是通过一个新的对象封装原有的对象。二者之间的差异在于代理模式是为了实现对象的控制，可能被代理的对象难以直接获得或者是不想暴露给客户端，而装饰者模式是继承的一种替代方案，在避免创建过多子类的情况下为被装饰者提供更多的功能。

装饰器模式应当为所装饰的对象提供增强功能，而代理模式对所代理对象的使用施加控制，并不提供对象本身的增强功能。

第一段说的是代理模式，侧重于不能直接访问一个对象，只能通过代理来间接访问，比如对象在另外一台机器上，或者对象被持久化了，对象是受保护的。对象在另外一台机器上，其实就是rpc，感兴趣的可以看看dubbo的源码本地反问的其实就是远程对象的代理，只不过代理帮你做了访问这个对象之前和之后的很多事情，但是对使用者是透明的了。对象被持久化了，比如mybatis的mapperProxy。通过mapper文件自动生成代理类。第三种，对内核对象的访问。  第二段说的是装饰器模式是因为没法在编译器就确定一个对象的功能，需要运行时动态的给对象添加职责，所以只能把对象的功能拆成一一个个的小部分，动态组装，感兴趣的可以看看dubbo的源码，里面的mock，cluster，failover都是通过装饰器来实现的。因为这些功能是由使用者动态配置的。但是代理模式在编译器其实就已经确定了和代理对象的关系。    第三段说的是，这个两个设计模式是为了解决不同的问题而抽象总结出来的。是可以混用的。可以在代理的基础上在加一个装饰，也可以在装饰器的基础上在加一个代理。感兴趣的去看看dubbo源码，里面就是这么实现的。

作者：不知道起什么名字
链接：https://www.zhihu.com/question/41988550/answer/567925484
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。